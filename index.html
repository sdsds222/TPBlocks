<!DOCTYPE html>
<html lang="zh-CN">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<title>TPBlocks</title>
<style>
  body { font-family: system-ui, -apple-system, "Segoe UI", Arial; display:flex; flex-direction:column; align-items:center; gap:16px; padding:20px; background:#f7f7f7; margin:0; }
  h1 { margin:0; font-size:20px; }
  .mode-indicator { font-size:16px; font-weight:600; color:#666; }
  .board { display:grid; grid-template-columns: repeat(5, 64px); grid-template-rows: repeat(5, 64px); gap:6px; }
  .cell { width:64px; height:64px; border-radius:10px; display:flex; align-items:center; justify-content:center; font-weight:700; font-size:18px; cursor:pointer; background:#e6e6e6; color:#fff; box-shadow: inset 0 0 0 2px #ddd; transition: transform 0.1s; }
  .cell:hover { transform: scale(1.05); }
  .cell.empty { color:#999; background:#f0f0f0; box-shadow: inset 0 0 0 2px #e4e4e4; }
  .cell.selected { outline: 3px solid #ff9f1c; }
  .block-1 { background:#ff6b6b; }
  .block-2 { background:#4ecdc4; }
  .block-3 { background:#ffd166; color:#333; }
  .block-4 { background:#06d6a0; }
  .block-5 { background:#118ab2; }
  .block-6 { background:#8338ec; }
  .block-7 { background:#fb5607; }
  .block-8 { background:#3a86ff; }
  .block-9 { background:#e63946; }
  .block-10 { background:#2a9d8f; }
  .block-11 { background:#f77f00; }
  .block-12 { background:#d62828; }
  .panel { display:flex; gap:8px; flex-wrap:wrap; justify-content:center; max-width:700px; }
  button { padding:10px 16px; border:0; border-radius:8px; background:#999; color:#fff; font-weight:600; cursor:pointer; transition: background 0.2s; font-size:14px; }
  button:hover { background:#777; }
  button:active { background:#2b7 !important; }
  button.secondary { background:#999; }
  button.secondary:hover { background:#777; }
  button.secondary:active { background:#2b7 !important; }
  button.danger { background:#e74; }
  button.danger:hover { background:#c52; }
  button.danger:active { background:#2b7 !important; }
  button.active { background:#2b7 !important; }
  button.active:hover { background:#1a6 !important; }
  button.active:active { background:#2b7 !important; }
  .msg { min-height:28px; color:#333; font-weight:500; font-size:15px; text-align:center; }
  .score { font-size:18px; font-weight:700; color:#2b7; margin:8px 0; }
  
  /* ç¼–è¾‘å™¨é¢„è§ˆ */
  #nextBlockPreview { box-shadow: 0 2px 6px rgba(0,0,0,0.15); }
  
  /* å…³å¡åˆ—è¡¨ */
  .level-list { max-width:500px; background:#fff; border-radius:10px; padding:16px; box-shadow: 0 2px 8px rgba(0,0,0,0.1); max-height:400px; overflow-y:auto; }
  .level-item { padding:12px; background:#f7f7f7; border-radius:8px; margin-bottom:8px; cursor:pointer; transition:all 0.2s; display:flex; justify-content:space-between; align-items:center; }
  .level-item:hover { background:#e0e0e0; transform: translateX(4px); }
  .level-item button { padding:6px 12px; font-size:12px; margin-left:8px; }
  
  .info { max-width:680px; font-size:13px; line-height:1.5; color:#666; background:#fff; padding:10px 14px; border-radius:8px; box-shadow: 0 2px 6px rgba(0,0,0,0.05); margin-top:8px; }
  
  .view { display:none; }
  .view.active { display:flex; flex-direction:column; align-items:center; gap:16px; }
  
  .save-input { padding:10px; border-radius:6px; border:2px solid #ddd; width:250px; font-size:14px; margin-right:8px; }
  
  /* è™šæ‹Ÿæ–¹å‘é”®æ ·å¼ */
  #virtualControls {
    position: fixed;
    bottom: 30px;
    right: 30px;
    display: grid;
    grid-template-areas: 
      ". up ."
      "left . right"
      ". down .";
    gap: 10px;
    padding: 15px;
    background: rgba(255, 255, 255, 0.9);
    border-radius: 50%;
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
    z-index: 100;
    touch-action: none;
  }
  
  .control-btn {
    width: 50px;
    height: 50px;
    border-radius: 50%;
    background: #2b7;
    color: white;
    border: none;
    font-size: 20px;
    font-weight: bold;
    display: flex;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    transition: all 0.1s;
    box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
    user-select: none;
  }
  
  .control-btn:active {
    background: #1a6;
    transform: scale(0.95);
    box-shadow: 0 1px 3px rgba(0, 0, 0, 0.2);
  }
  
  #upBtn { grid-area: up; }
  #leftBtn { grid-area: left; }
  #downBtn { grid-area: down; }
  #rightBtn { grid-area: right; }
  
  /* åœ¨æ¡Œé¢è®¾å¤‡ä¸Šéšè—è™šæ‹Ÿæ–¹å‘é”® */
  @media (min-width: 1024px) {
    #virtualControls {
      display: none;
    }
  }
</style>
</head>
<body>
  <h1>TPBlocks</h1>
  <div class="mode-indicator" id="modeIndicator">ğŸ® æ¸¸æˆæ¨¡å¼</div>

  <div class="panel">
    <button id="playModeBtn" class="active">æ¸¸æˆæ¨¡å¼</button>
    <button id="endlessModeBtn" class="secondary">æ— å°½æ¨¡å¼</button>
    <button id="editorModeBtn" class="secondary">å…³å¡ç¼–è¾‘å™¨</button>
    <button id="loadLevelBtn" class="secondary">è½½å…¥å…³å¡</button>
  </div>

  <!-- æ¸¸æˆæ¨¡å¼è§†å›¾ -->
  <div id="playView" class="view active">
    <div class="panel">
      <button id="resetBtn">éšæœºå…³å¡</button>
      <button id="presetBtn" class="secondary">ç¤ºä¾‹å…³å¡</button>
    </div>
    <div id="playBoard" class="board"></div>
    <div id="playMsg" class="msg"></div>
    <div class="info">
      <b>ç©æ³•ï¼š</b>ç‚¹å‡»æ–¹å—é€‰ä¸­ï¼Œç”¨æ–¹å‘é”®ç§»åŠ¨ã€‚æ–¹å—å¯ä¼ é€ï¼Œç›¸åŒæ•°å­—æ–¹å—ç›¸é‚»æ»‘åŠ¨ä¼šæ¶ˆé™¤ã€‚A game designed by sdsds222 (2025)
    </div>
  </div>

  <!-- æ— å°½æ¨¡å¼è§†å›¾ -->
  <div id="endlessView" class="view">
    <div class="panel">
      <button id="endlessStartBtn">å¼€å§‹æ¸¸æˆ</button>
      <button id="endlessRestartBtn" class="secondary" style="display:none;">é‡æ–°å¼€å§‹</button>
    </div>
    <div class="score" id="endlessScore">ç§»åŠ¨æ¬¡æ•°: 0</div>
    <div id="endlessBoard" class="board"></div>
    <div id="endlessMsg" class="msg"></div>
    <div class="info">
      <b>æ— å°½æ¨¡å¼ï¼š</b>æ¯3æ¬¡æˆåŠŸç§»åŠ¨ï¼ˆåŒ…æ‹¬æ¶ˆé™¤ã€ä¼ é€ã€å¯¹è°ƒï¼‰éƒ½ä¼šæ·»åŠ ä¸€å¯¹æ–°æ–¹å—ã€‚æ•°å­—ä¼˜å…ˆé€’å¢ï¼ˆ1â†’2â†’3...ï¼‰ï¼Œå½“è¶…è¿‡12åä¼šé‡ç”¨å·²æ¶ˆé™¤çš„1-12å·é¢œè‰²ä»¥ä¿æŒè§†è§‰å¯¹æ¯”åº¦ã€‚å½“æ²¡æœ‰ç©ºä½æ·»åŠ æ–°æ–¹å—æ—¶æ¸¸æˆç»“æŸï¼
    </div>
  </div>

  <!-- ç¼–è¾‘å™¨è§†å›¾ -->
  <div id="editorView" class="view">
    <div class="panel">
      <button id="placeBtn">æ”¾ç½®æ–¹å—</button>
      <button id="deleteBtn">åˆ é™¤æ–¹å—</button>
      <button id="clearBtn" class="danger">æ¸…ç©ºæ£‹ç›˜</button>
    </div>
    <div style="margin: 8px 0; font-size: 14px; color: #666;">
      <span>ä¸‹ä¸€ä¸ªæ–¹å—ï¼š</span>
      <span id="nextBlockPreview" style="display:inline-block; width:32px; height:32px; border-radius:6px; text-align:center; line-height:32px; color:#fff; font-weight:700; margin-left:8px;"></span>
      <span id="nextBlockText" style="margin-left:8px; font-weight:600;"></span>
      <span id="capacityInfo" style="margin-left:16px; font-weight:600; color:#666;"></span>
    </div>
    <div class="panel">
      <button id="testBtn">â–¶ æµ‹è¯•å…³å¡</button>
      <button id="saveBtn">ä¿å­˜å…³å¡</button>
      <button id="backToEditBtn" class="secondary" style="display:none;">è¿”å›ç¼–è¾‘</button>
    </div>
    <div id="editorBoard" class="board"></div>
    <div id="editorMsg" class="msg"></div>
    <div id="saveArea" style="display:none; margin-top:8px;">
      <input type="text" id="levelName" class="save-input" placeholder="è¾“å…¥å…³å¡åç§°...">
      <button onclick="saveLevelWithName()">ç¡®è®¤</button>
      <button onclick="cancelSave()" class="secondary">å–æ¶ˆ</button>
    </div>
    <div class="info">
      <b>ç¼–è¾‘å™¨ï¼š</b>ç‚¹å‡»"æ”¾ç½®æ–¹å—"ï¼Œç„¶åç‚¹å‡»æ£‹ç›˜ä¸¤æ¬¡æ”¾ç½®ä¸€å¯¹é…å¯¹æ–¹å—ã€‚è‡ªåŠ¨æŒ‰é¡ºåºç¼–å·ã€‚æ£‹ç›˜æœ€å¤šæ”¾ç½®12å¯¹æ–¹å—ï¼ˆéœ€ä¿ç•™è‡³å°‘1ä¸ªç©ºæ ¼ï¼‰ã€‚
    </div>
  </div>

  <!-- è½½å…¥å…³å¡è§†å›¾ -->
  <div id="loadView" class="view">
    <div class="level-list" id="levelList"></div>
    <div class="info">
      <b>æç¤ºï¼š</b>ç‚¹å‡»å…³å¡å³å¯è½½å…¥åˆ°æ¸¸æˆæ¨¡å¼ã€‚åœ¨ç¼–è¾‘å™¨ä¸­ä¿å­˜çš„å…³å¡ä¼šæ˜¾ç¤ºåœ¨è¿™é‡Œã€‚
    </div>
  </div>

  <!-- è™šæ‹Ÿæ–¹å‘é”® -->
  <div id="virtualControls">
    <button id="upBtn" class="control-btn">â†‘</button>
    <button id="leftBtn" class="control-btn">â†</button>
    <button id="downBtn" class="control-btn">â†“</button>
    <button id="rightBtn" class="control-btn">â†’</button>
  </div>

<script>
  const SIZE = 5;
  const DIRS = {
    ArrowUp: {x:0, y:-1}, ArrowDown: {x:0, y:1},
    ArrowLeft: {x:-1, y:0}, ArrowRight: {x:1, y:0}
  };

  let currentView = 'play';
  let currentMode = 'play'; // play, endless, editor, editorTest
  let board = Array.from({length:SIZE}, ()=> Array(SIZE).fill(0));
  let selected = null;
  let blocksRemaining = 0;
  
  // ç¼–è¾‘å™¨çŠ¶æ€
  let editorMode = 'place'; // 'place' or 'delete'
  let nextBlockNumber = 1;
  let placingBlock = null; // {type: number, firstPos: {x, y}} æ­£åœ¨æ”¾ç½®çš„æ–¹å—
  
  // æ— å°½æ¨¡å¼çŠ¶æ€
  let endlessMoves = 0;
  let endlessNextType = 1; // ä¸‹ä¸€ä¸ªè¦æ·»åŠ çš„æ–¹å—ç±»å‹
  let endlessGameOver = false;
  let movesUntilNewBlocks = 0; // æ·»åŠ æ–°æ–¹å—å‰çš„å‰©ä½™ç§»åŠ¨æ¬¡æ•°

  function inside(x,y){ return x>=0 && x<SIZE && y>=0 && y<SIZE; }

  // ========== è§†å›¾åˆ‡æ¢ ==========
  function switchView(view, preserveBoard = false){
    document.querySelectorAll('.view').forEach(v => v.classList.remove('active'));
    document.getElementById(view + 'View').classList.add('active');
    currentView = view;
    
    // æ›´æ–°é¡¶éƒ¨æŒ‰é’®çŠ¶æ€
    const allBtns = document.querySelectorAll('#playModeBtn, #endlessModeBtn, #editorModeBtn, #loadLevelBtn');
    allBtns.forEach(btn => {
      btn.classList.remove('active');
      btn.classList.add('secondary');
    });
    
    const btnMap = {
      play: 'playModeBtn',
      endless: 'endlessModeBtn',
      editor: 'editorModeBtn',
      load: 'loadLevelBtn'
    };
    const activeBtn = document.getElementById(btnMap[view]);
    activeBtn.classList.remove('secondary');
    activeBtn.classList.add('active');
    
    const indicators = {
      play: 'æ¸¸æˆæ¨¡å¼',
      endless: 'æ— å°½æ¨¡å¼',
      editor: 'å…³å¡ç¼–è¾‘å™¨',
      load: 'è½½å…¥å…³å¡'
    };
    document.getElementById('modeIndicator').textContent = indicators[view];
    
    // ä¿®å¤ï¼šåˆ‡æ¢è§†å›¾æ—¶æ›´æ–°å½“å‰æ¨¡å¼
    if (view === 'play') {
      currentMode = 'play';
      if(!preserveBoard){
        resetRandom();
      } else {
        renderBoard('play');
      }
    } else if (view === 'endless') {
      currentMode = 'endless';
    } else if (view === 'editor') {
      currentMode = 'editor';
      initEditor();
    }
  }

  document.getElementById('playModeBtn').onclick = () => {
    switchView('play');
  };
  
  document.getElementById('endlessModeBtn').onclick = () => {
    switchView('endless');
    showMsg('endless', 'ç‚¹å‡»"å¼€å§‹æ¸¸æˆ"å¼€å§‹æ— å°½æŒ‘æˆ˜ï¼');
  };
  
  document.getElementById('editorModeBtn').onclick = () => {
    switchView('editor');
  };
  
  document.getElementById('loadLevelBtn').onclick = () => {
    switchView('load');
    loadSavedLevels();
  };

  // ========== æ¸¸æˆæ¨¡å¼ ==========
  function resetRandom(){
    board = Array.from({length:SIZE}, ()=> Array(SIZE).fill(0));
    const pairs = [1,2,3,4,5];
    pairs.forEach(t => placeRandomPair(t));
    selected = null;
    renderBoard('play');
    showMsg('play', 'éšæœºå…³å¡å·²ç”Ÿæˆ');
  }

  function loadPreset(){
    board = Array.from({length:SIZE}, ()=> Array(SIZE).fill(0));
    board[0][2]=1; board[0][3]=1;
    board[0][0]=2; board[0][1]=2;
    board[2][2]=3; board[2][4]=3;
    board[1][1]=4; board[3][3]=4;
    board[4][4]=5; board[0][4]=5;
    selected = null;
    renderBoard('play');
    showMsg('play', 'ç¤ºä¾‹å…³å¡å·²è½½å…¥');
  }

  function placeRandomPair(type){
    let placed = 0;
    while(placed < 2){
      const x = Math.floor(Math.random()*SIZE);
      const y = Math.floor(Math.random()*SIZE);
      if(board[y][x] === 0){
        board[y][x] = type;
        placed++;
      }
    }
  }

  document.getElementById('resetBtn').onclick = resetRandom;
  document.getElementById('presetBtn').onclick = loadPreset;

  // ========== æ— å°½æ¨¡å¼ ==========
  function startEndless(){
    board = Array.from({length:SIZE}, ()=> Array(SIZE).fill(0));
    // åˆå§‹æ”¾ç½®3å¯¹æ–¹å—
    placeRandomPair(1);
    placeRandomPair(2);
    placeRandomPair(3);
    endlessMoves = 0;
    movesUntilNewBlocks = 3; // åˆå§‹è®¾ç½®ä¸º3ï¼Œéœ€è¦3æ¬¡ç§»åŠ¨æ‰æ·»åŠ æ–°æ–¹å—
    endlessNextType = 4; // ä¸‹ä¸€ä¸ªè¦æ·»åŠ çš„ç±»å‹ä»4å¼€å§‹
    endlessGameOver = false;
    selected = null;
    currentMode = 'endless';
    document.getElementById('endlessStartBtn').style.display = 'none';
    document.getElementById('endlessRestartBtn').style.display = 'inline-block';
    updateEndlessScore();
    renderBoard('endless');
    showMsg('endless', 'æ— å°½æ¨¡å¼å¼€å§‹ï¼æ¯3æ¬¡æˆåŠŸç§»åŠ¨æ·»åŠ ä¸€å¯¹æ–°æ–¹å—');
  }

  function updateEndlessScore(){
    document.getElementById('endlessScore').textContent = `ç§»åŠ¨æ¬¡æ•°: ${endlessMoves} (è¿˜éœ€${movesUntilNewBlocks}æ¬¡ç§»åŠ¨æ·»åŠ æ–°æ–¹å—)`;
  }

  function addRandomPairEndless(){
    // æ‰¾å‡ºæ‰€æœ‰ç©ºä½
    const emptySpots = [];
    for(let y=0; y<SIZE; y++){
      for(let x=0; x<SIZE; x++){
        if(board[y][x] === 0) emptySpots.push({x, y});
      }
    }
    
    if(emptySpots.length < 2){
      // æ¸¸æˆç»“æŸ
      endlessGameOver = true;
      showMsg('endless', `æ¸¸æˆç»“æŸï¼å…±å®Œæˆ ${endlessMoves} æ¬¡ç§»åŠ¨ï¼`);
      return false;
    }
    
    let newType;
    
    // ç­–ç•¥ï¼šä¼˜å…ˆä½¿ç”¨é€’å¢ç¼–å·ï¼Œä½†å½“ç¼–å·>12æ—¶ï¼Œæ£€æŸ¥1-12æ˜¯å¦æœ‰ç©ºé—²çš„å¯ä»¥é‡ç”¨
    if(endlessNextType <= 12){
      // ç¼–å·è¿˜åœ¨1-12èŒƒå›´å†…ï¼Œç›´æ¥ä½¿ç”¨
      newType = endlessNextType;
      endlessNextType++;
    } else {
      // ç¼–å·è¶…è¿‡12ï¼Œæ£€æŸ¥1-12ä¸­æ˜¯å¦æœ‰æœªä½¿ç”¨çš„
      const usedTypes = new Set();
      for(let y=0; y<SIZE; y++){
        for(let x=0; x<SIZE; x++){
          if(board[y][x] > 0) usedTypes.add(board[y][x]);
        }
      }
      
      // æ‰¾åˆ°1-12ä¸­æœ€å°çš„æœªä½¿ç”¨ç¼–å·
      let foundReuse = false;
      for(let i=1; i<=12; i++){
        if(!usedTypes.has(i)){
          newType = i;
          foundReuse = true;
          break;
        }
      }
      
      // å¦‚æœ1-12éƒ½åœ¨ä½¿ç”¨ï¼Œç»§ç»­é€’å¢
      if(!foundReuse){
        newType = endlessNextType;
        endlessNextType++;
      }
    }
    
    // éšæœºæ”¾ç½®ä¸¤ä¸ªä½ç½®
    const idx1 = Math.floor(Math.random() * emptySpots.length);
    const spot1 = emptySpots.splice(idx1, 1)[0];
    const idx2 = Math.floor(Math.random() * emptySpots.length);
    const spot2 = emptySpots[idx2];
    
    board[spot1.y][spot1.x] = newType;
    board[spot2.y][spot2.x] = newType;
    
    showMsg('endless', `æ·»åŠ äº†æ–¹å— ${newType}ï¼`);
    return true;
  }

  document.getElementById('endlessStartBtn').onclick = startEndless;
  document.getElementById('endlessRestartBtn').onclick = () => {
    document.getElementById('endlessStartBtn').style.display = 'inline-block';
    document.getElementById('endlessRestartBtn').style.display = 'none';
    showMsg('endless', 'ç‚¹å‡»"å¼€å§‹æ¸¸æˆ"å¼€å§‹æ— å°½æŒ‘æˆ˜ï¼');
  };

  // ========== ç¼–è¾‘å™¨ ==========
  function initEditor(){
    board = Array.from({length:SIZE}, ()=> Array(SIZE).fill(0));
    selected = null;
    editorMode = 'place';
    nextBlockNumber = 1;
    placingBlock = null;
    updateEditorButtons();
    updateNextBlockPreview();
    updateCapacityInfo();
    renderBoard('editor');
    showMsg('editor', 'ç‚¹å‡»"æ”¾ç½®æ–¹å—"ï¼Œç„¶ååœ¨æ£‹ç›˜ä¸Šç‚¹å‡»ä¸¤æ¬¡æ”¾ç½®ä¸€å¯¹æ–¹å—');
  }

  function updateCapacityInfo(){
    const totalCells = SIZE * SIZE;
    const usedCells = countBlocks();
    const maxPairs = Math.floor((totalCells - 1) / 2); // è‡³å°‘ç•™ä¸€ä¸ªç©ºæ ¼
    const currentPairs = usedCells / 2;
    
    const capacityText = document.getElementById('capacityInfo');
    if(capacityText){
      capacityText.textContent = `å®¹é‡ï¼š${currentPairs}/${maxPairs} å¯¹ (${usedCells}/${totalCells-1} æ ¼)`;
      if(currentPairs >= maxPairs){
        capacityText.style.color = '#e74';
      } else {
        capacityText.style.color = '#666';
      }
    }
  }

  function canPlaceMoreBlocks(){
    const totalCells = SIZE * SIZE;
    const usedCells = countBlocks();
    // è‡³å°‘éœ€è¦ç•™1ä¸ªç©ºæ ¼ï¼Œæ‰€ä»¥æœ€å¤šç”¨24ä¸ªæ ¼å­ï¼ˆ12å¯¹æ–¹å—ï¼‰
    return usedCells < (totalCells - 1);
  }

  function updateEditorButtons(){
    const placeBtn = document.getElementById('placeBtn');
    const deleteBtn = document.getElementById('deleteBtn');
    
    // ç§»é™¤æ‰€æœ‰active class
    placeBtn.classList.remove('active');
    deleteBtn.classList.remove('active');
    
    // æ ¹æ®å½“å‰æ¨¡å¼æ·»åŠ active class
    if(editorMode === 'place'){
      placeBtn.classList.add('active');
    } else {
      deleteBtn.classList.add('active');
    }
    
    // æ£€æŸ¥å®¹é‡ï¼Œå¦‚æœæ»¡äº†ç¦ç”¨æ”¾ç½®æŒ‰é’®
    if(!canPlaceMoreBlocks()){
      placeBtn.disabled = true;
      placeBtn.style.opacity = '0.5';
      placeBtn.style.cursor = 'not-allowed';
    } else {
      placeBtn.disabled = false;
      placeBtn.style.opacity = '1';
      placeBtn.style.cursor = 'pointer';
    }
  }

  function updateNextBlockPreview(){
    const preview = document.getElementById('nextBlockPreview');
    const text = document.getElementById('nextBlockText');
    
    if(nextBlockNumber > 12){
      preview.style.background = '#999';
      preview.textContent = nextBlockNumber;
      text.textContent = `æ–¹å— ${nextBlockNumber}`;
    } else {
      preview.className = 'block-' + nextBlockNumber;
      preview.textContent = nextBlockNumber;
      text.textContent = `æ–¹å— ${nextBlockNumber}`;
    }
  }

  function getNextBlockNumber(){
    // æ‰¾å‡ºå½“å‰æœ€å¤§çš„æ–¹å—ç¼–å·
    let maxNum = 0;
    for(let y=0; y<SIZE; y++){
      for(let x=0; x<SIZE; x++){
        if(board[y][x] > maxNum) maxNum = board[y][x];
      }
    }
    return maxNum + 1;
  }

  document.getElementById('placeBtn').onclick = () => {
    if(!canPlaceMoreBlocks()){
      showMsg('editor', 'æ£‹ç›˜å·²æ»¡ï¼æœ€å¤šå¯æ”¾ç½®12å¯¹æ–¹å—ï¼ˆéœ€ä¿ç•™è‡³å°‘1ä¸ªç©ºæ ¼ï¼‰');
      return;
    }
    editorMode = 'place';
    placingBlock = null;
    updateEditorButtons();
    showMsg('editor', 'æ”¾ç½®æ¨¡å¼ï¼šåœ¨æ£‹ç›˜ä¸Šç‚¹å‡»ä¸¤æ¬¡æ”¾ç½®ä¸€å¯¹æ–¹å—');
  };

  document.getElementById('deleteBtn').onclick = () => {
    editorMode = 'delete';
    placingBlock = null;
    updateEditorButtons();
    showMsg('editor', 'åˆ é™¤æ¨¡å¼ï¼šç‚¹å‡»æ–¹å—è¿›è¡Œåˆ é™¤');
  };

  document.getElementById('clearBtn').onclick = () => {
    if(countBlocks() > 0 && !confirm('ç¡®å®šè¦æ¸…ç©ºæ•´ä¸ªæ£‹ç›˜å—ï¼Ÿ')) return;
    board = Array.from({length:SIZE}, ()=> Array(SIZE).fill(0));
    editorMode = 'place';
    placingBlock = null;
    nextBlockNumber = 1;
    updateEditorButtons();
    updateNextBlockPreview();
    updateCapacityInfo();
    renderBoard('editor');
    showMsg('editor', 'æ£‹ç›˜å·²æ¸…ç©º');
  };

  document.getElementById('testBtn').onclick = () => {
    // æ£€æŸ¥æ˜¯å¦æ‰€æœ‰æ–¹å—éƒ½æˆå¯¹
    const typeCounts = {};
    for(let y=0; y<SIZE; y++){
      for(let x=0; x<SIZE; x++){
        const v = board[y][x];
        if(v > 0){
          typeCounts[v] = (typeCounts[v] || 0) + 1;
        }
      }
    }
    
    for(let type in typeCounts){
      if(typeCounts[type] !== 2){
        showMsg('editor', `é”™è¯¯ï¼šæ–¹å—${type}åªæœ‰${typeCounts[type]}ä¸ªï¼Œå¿…é¡»æ˜¯2ä¸ªï¼`);
        return;
      }
    }
    
    if(countBlocks() === 0){
      showMsg('editor', 'æ£‹ç›˜ä¸ºç©ºï¼Œæ— æ³•æµ‹è¯•');
      return;
    }
    
    currentMode = 'editorTest';
    selected = null;
    document.getElementById('placeBtn').style.display = 'none';
    document.getElementById('deleteBtn').style.display = 'none';
    document.getElementById('testBtn').style.display = 'none';
    document.getElementById('saveBtn').style.display = 'none';
    document.getElementById('nextBlockPreview').parentElement.style.display = 'none';
    document.getElementById('backToEditBtn').style.display = 'inline-block';
    
    // ä¿®å¤ï¼šåœ¨æµ‹è¯•æ¨¡å¼ä¸‹éšè—æ¸…ç©ºæŒ‰é’®
    document.getElementById('clearBtn').style.display = 'none';
    
    renderBoard('editor');
    showMsg('editor', 'æµ‹è¯•æ¨¡å¼ï¼šç‚¹å‡»æ–¹å—ï¼Œç”¨æ–¹å‘é”®ç§»åŠ¨');
  };

  // ä¿®å¤ï¼šè¿”å›ç¼–è¾‘æŒ‰é’®åŠŸèƒ½
  document.getElementById('backToEditBtn').onclick = () => {
    // é‡æ–°æ˜¾ç¤ºç¼–è¾‘å™¨æŒ‰é’®
    document.getElementById('placeBtn').style.display = 'inline-block';
    document.getElementById('deleteBtn').style.display = 'inline-block';
    document.getElementById('testBtn').style.display = 'inline-block';
    document.getElementById('saveBtn').style.display = 'inline-block';
    document.getElementById('nextBlockPreview').parentElement.style.display = 'block';
    document.getElementById('backToEditBtn').style.display = 'none';
    document.getElementById('clearBtn').style.display = 'inline-block';
    
    // é‡ç½®æ¨¡å¼
    currentMode = 'editor';
    
    // é‡æ–°åˆå§‹åŒ–ç¼–è¾‘å™¨çŠ¶æ€
    updateEditorButtons();
    updateNextBlockPreview();
    updateCapacityInfo();
    
    // é‡æ–°æ¸²æŸ“æ£‹ç›˜
    renderBoard('editor');
    showMsg('editor', 'è¿”å›ç¼–è¾‘æ¨¡å¼');
  };

  document.getElementById('saveBtn').onclick = () => {
    // æ£€æŸ¥æ˜¯å¦æ‰€æœ‰æ–¹å—éƒ½æˆå¯¹
    const typeCounts = {};
    for(let y=0; y<SIZE; y++){
      for(let x=0; x<SIZE; x++){
        const v = board[y][x];
        if(v > 0){
          typeCounts[v] = (typeCounts[v] || 0) + 1;
        }
      }
    }
    
    for(let type in typeCounts){
      if(typeCounts[type] !== 2){
        showMsg('editor', `é”™è¯¯ï¼šæ–¹å—${type}åªæœ‰${typeCounts[type]}ä¸ªï¼`);
        return;
      }
    }
    
    if(countBlocks() === 0){
      showMsg('editor', 'æ£‹ç›˜ä¸ºç©º');
      return;
    }
    document.getElementById('saveArea').style.display = 'block';
    document.getElementById('levelName').focus();
  };

  window.saveLevelWithName = function(){
    const name = document.getElementById('levelName').value.trim();
    if(!name){
      showMsg('editor', 'è¯·è¾“å…¥å…³å¡åç§°');
      return;
    }
    
    const levels = JSON.parse(localStorage.getItem('customLevels') || '[]');
    levels.push({
      id: Date.now(),
      name: name,
      board: JSON.stringify(board),
      createdAt: new Date().toLocaleString('zh-CN')
    });
    localStorage.setItem('customLevels', JSON.stringify(levels));
    
    document.getElementById('saveArea').style.display = 'none';
    document.getElementById('levelName').value = '';
    showMsg('editor', `å…³å¡"${name}"å·²ä¿å­˜ï¼`);
  };

  window.cancelSave = function(){
    document.getElementById('saveArea').style.display = 'none';
    document.getElementById('levelName').value = '';
  };

  // ========== è½½å…¥å…³å¡ ==========
  function loadSavedLevels(){
    const levels = JSON.parse(localStorage.getItem('customLevels') || '[]');
    const listEl = document.getElementById('levelList');
    
    if(levels.length === 0){
      listEl.innerHTML = '<div style="text-align:center; color:#999; padding:40px;">æš‚æ— ä¿å­˜çš„å…³å¡<br><small>åœ¨å…³å¡ç¼–è¾‘å™¨ä¸­åˆ›å»ºå¹¶ä¿å­˜å…³å¡</small></div>';
      return;
    }
    
    listEl.innerHTML = '<h3 style="margin:0 0 12px 0; font-size:16px;">å·²ä¿å­˜çš„å…³å¡</h3>';
    levels.forEach(level => {
      const item = document.createElement('div');
      item.className = 'level-item';
      item.innerHTML = `
        <div>
          <div style="font-weight:600;">${level.name}</div>
          <div style="font-size:11px; color:#999; margin-top:2px;">${level.createdAt}</div>
        </div>
        <div>
          <button class="secondary load-btn" data-id="${level.id}">è½½å…¥</button>
          <button class="danger delete-btn" data-id="${level.id}">åˆ é™¤</button>
        </div>
      `;
      
      // æ·»åŠ äº‹ä»¶ç›‘å¬å™¨
      const loadBtn = item.querySelector('.load-btn');
      const deleteBtn = item.querySelector('.delete-btn');
      
      loadBtn.addEventListener('click', (e) => {
        e.stopPropagation();
        loadCustomLevel(level.id);
      });
      
      deleteBtn.addEventListener('click', (e) => {
        e.stopPropagation();
        deleteLevel(level.id);
      });
      
      listEl.appendChild(item);
    });
  }

  function loadCustomLevel(id){
    const levels = JSON.parse(localStorage.getItem('customLevels') || '[]');
    const level = levels.find(l => l.id === id);
    if(level){
      board = JSON.parse(level.board);
      selected = null;
      switchView('play', true);
      currentMode = 'play';
      renderBoard('play');
      showMsg('play', `å·²è½½å…¥å…³å¡ï¼š${level.name}`);
    }
  }

  function deleteLevel(id){
    if(!confirm('ç¡®å®šåˆ é™¤è¿™ä¸ªå…³å¡ï¼Ÿ')) return;
    let levels = JSON.parse(localStorage.getItem('customLevels') || '[]');
    levels = levels.filter(l => l.id !== id);
    localStorage.setItem('customLevels', JSON.stringify(levels));
    loadSavedLevels();
  }

  // ========== é€šç”¨æ¸²æŸ“ ==========
  function renderBoard(mode){
    const boardEl = document.getElementById(mode + 'Board');
    boardEl.innerHTML = '';
    
    for(let y=0; y<SIZE; y++){
      for(let x=0; x<SIZE; x++){
        const v = board[y][x];
        const cell = document.createElement('div');
        cell.className = 'cell';
        if(v===0) cell.classList.add('empty');
        else cell.classList.add('block-'+v);
        cell.textContent = v===0 ? '' : String(v);
        
        if(selected && selected.x===x && selected.y===y && currentMode !== 'editor'){
          cell.classList.add('selected');
        }
        
        cell.onclick = () => handleCellClick(x, y, mode);
        boardEl.appendChild(cell);
      }
    }
    blocksRemaining = countBlocks();
  }

  function handleCellClick(x, y, mode){
    if(currentMode === 'editor'){
      if(editorMode === 'delete'){
        // åˆ é™¤æ¨¡å¼
        if(board[y][x] !== 0){
          const deletedType = board[y][x];
          // åˆ é™¤è¿™å¯¹æ–¹å—
          for(let dy=0; dy<SIZE; dy++){
            for(let dx=0; dx<SIZE; dx++){
              if(board[dy][dx] === deletedType){
                board[dy][dx] = 0;
              }
            }
          }
          showMsg('editor', `å·²åˆ é™¤æ–¹å— ${deletedType}`);
          nextBlockNumber = getNextBlockNumber();
          updateNextBlockPreview();
          updateCapacityInfo();
          updateEditorButtons();
          renderBoard('editor');
        }
      } else {
        // æ”¾ç½®æ¨¡å¼
        if(board[y][x] !== 0){
          showMsg('editor', 'è¯¥ä½ç½®å·²æœ‰æ–¹å—');
          return;
        }
        
        if(!canPlaceMoreBlocks() && !placingBlock){
          showMsg('editor', 'æ£‹ç›˜å·²æ»¡ï¼æœ€å¤š12å¯¹æ–¹å—');
          return;
        }
        
        if(!placingBlock){
          // æ”¾ç½®ç¬¬ä¸€ä¸ª
          placingBlock = {
            type: nextBlockNumber,
            firstPos: {x, y}
          };
          board[y][x] = nextBlockNumber;
          showMsg('editor', `æ”¾ç½®äº†ç¬¬1ä¸ªæ–¹å— ${nextBlockNumber}ï¼Œå†ç‚¹å‡»ä¸€ä¸ªç©ºä½æ”¾ç½®ç¬¬2ä¸ª`);
          renderBoard('editor');
        } else {
          // æ”¾ç½®ç¬¬äºŒä¸ª
          board[y][x] = placingBlock.type;
          showMsg('editor', `å®Œæˆæ–¹å— ${placingBlock.type} çš„é…å¯¹`);
          nextBlockNumber++;
          updateNextBlockPreview();
          updateCapacityInfo();
          updateEditorButtons();
          placingBlock = null;
          renderBoard('editor');
        }
      }
    } else {
      // æ¸¸æˆæ¨¡å¼/æµ‹è¯•æ¨¡å¼/æ— å°½æ¨¡å¼
      const v = board[y][x];
      if(v===0){ 
        selected=null;
        renderBoard(mode);
        return;
      }
      selected={x,y};
      renderBoard(mode);
      showMsg(mode, `é€‰ä¸­æ–¹å— ${v}`);
    }
  }

  function showMsg(mode, text){
    document.getElementById(mode + 'Msg').textContent = text;
  }

  function countBlocks(){
    let c=0;
    for(let y=0;y<SIZE;y++) for(let x=0;x<SIZE;x++) if(board[y][x]>0) c++;
    return c;
  }

  // ========== æ¸¸æˆé€»è¾‘ ==========
  function findOtherOfType(type, excludeX, excludeY){
    for(let y=0;y<SIZE;y++){
      for(let x=0;x<SIZE;x++){
        if(board[y][x]===type && !(x===excludeX && y===excludeY)) return {x,y};
      }
    }
    return null;
  }

  function movePiece(fromX,fromY,toX,toY){
    board[toY][toX] = board[fromY][fromX];
    board[fromY][fromX] = 0;
  }

  function slideSelected(dirKey){
    if(!selected) return;
    if(currentMode !== 'play' && currentMode !== 'editorTest' && currentMode !== 'endless') return;
    if(currentMode === 'endless' && endlessGameOver) return;
    
    const dir = DIRS[dirKey];
    if(!dir) return;
    
    const renderMode = currentMode === 'editorTest' ? 'editor' : currentMode;
    const sx = selected.x, sy = selected.y;
    const sType = board[sy][sx];

    const nx = sx + dir.x, ny = sy + dir.y;
    if(!inside(nx,ny)){ showMsg(renderMode, 'ä¸èƒ½æ»‘å‡ºè¾¹ç•Œ'); return; }
    if(board[ny][nx]===0){ showMsg(renderMode, 'ä¸èƒ½å‘ç©ºæ ¼æ»‘åŠ¨'); return; }

    const neighborType = board[ny][nx];

    if(neighborType === sType){
      board[sy][sx] = 0;
      board[ny][nx] = 0;
      selected = null;
      
      if(currentMode === 'endless'){
        endlessMoves++;
        movesUntilNewBlocks--;
        updateEndlessScore();
        
        // æ¯3æ¬¡ç§»åŠ¨æ·»åŠ ä¸€å¯¹æ–°æ–¹å—
        if(movesUntilNewBlocks <= 0){
          if(!addRandomPairEndless()){
            renderBoard(renderMode);
            return;
          }
          movesUntilNewBlocks = 3; // é‡ç½®è®¡æ•°å™¨
        }
      }
      
      renderBoard(renderMode);
      showMsg(renderMode, `æ–¹å— ${sType} æ¶ˆé™¤`);
      if(countBlocks() === 0 && currentMode !== 'endless'){
        showMsg(renderMode, 'æ­å–œé€šå…³ï¼');
      }
      return;
    }

    const movingBlockSet = new Set([`${sx},${sy}`]);
    const result = resolveTeleportChain(sx, sy, sType, nx, ny, dir, 0, movingBlockSet, sx, sy, null);
    
    if(!result.success){
      showMsg(renderMode, result.message);
      return;
    }

    if(result.eliminated){
      selected = null;
      
      if(currentMode === 'endless'){
        endlessMoves++;
        movesUntilNewBlocks--;
        updateEndlessScore();
        
        // æ¯3æ¬¡ç§»åŠ¨æ·»åŠ ä¸€å¯¹æ–°æ–¹å—
        if(movesUntilNewBlocks <= 0){
          if(!addRandomPairEndless()){
            renderBoard(renderMode);
            return;
          }
          movesUntilNewBlocks = 3; // é‡ç½®è®¡æ•°å™¨
        }
      }
      
      renderBoard(renderMode);
      showMsg(renderMode, `æ–¹å— ${sType} ä¼ é€æ¶ˆé™¤`);
      if(countBlocks() === 0 && currentMode !== 'endless'){
        showMsg(renderMode, 'æ­å–œé€šå…³ï¼');
      }
      return;
    }

    if(result.swap){
      const {swapPortalX, swapPortalY, swapPortalType, finalX, finalY} = result;
      board[sy][sx] = 0;
      board[swapPortalY][swapPortalX] = 0;
      board[finalY][finalX] = sType;
      board[sy][sx] = swapPortalType;
      selected = {x:finalX, y:finalY};
      
      if(currentMode === 'endless'){
        endlessMoves++;
        movesUntilNewBlocks--;
        updateEndlessScore();
        
        // æ¯3æ¬¡ç§»åŠ¨æ·»åŠ ä¸€å¯¹æ–°æ–¹å—
        if(movesUntilNewBlocks <= 0){
          if(!addRandomPairEndless()){
            renderBoard(renderMode);
            showMsg(renderMode, `å¯¹è°ƒæˆåŠŸï¼æ¸¸æˆç»“æŸ`);
            return;
          }
          movesUntilNewBlocks = 3; // é‡ç½®è®¡æ•°å™¨
        }
      }
      
      renderBoard(renderMode);
      showMsg(renderMode, `å¯¹è°ƒå®Œæˆ`);
      return;
    }

    const {finalX, finalY} = result;
    board[sy][sx] = 0;
    board[finalY][finalX] = sType;
    selected = {x:finalX, y:finalY};
    
    if(currentMode === 'endless'){
      endlessMoves++;
      movesUntilNewBlocks--;
      updateEndlessScore();
      
      // æ¯3æ¬¡ç§»åŠ¨æ·»åŠ ä¸€å¯¹æ–°æ–¹å—
      if(movesUntilNewBlocks <= 0){
        if(!addRandomPairEndless()){
          renderBoard(renderMode);
          showMsg(renderMode, `ç§»åŠ¨æˆåŠŸï¼æ¸¸æˆç»“æŸ`);
          return;
        }
        movesUntilNewBlocks = 3; // é‡ç½®è®¡æ•°å™¨
      }
    }
    
    renderBoard(renderMode);
    showMsg(renderMode, `å·²ç§»åŠ¨`);
  }

  function resolveTeleportChain(movingX, movingY, movingType, startX, startY, dir, depth, movingBlockSet, originX, originY, potentialSwapPortal){
    if(depth > 50) return {success:false, message:'é€’å½’è¶…é™'};

    let encounteredType = board[startY][startX];
    let currentX = startX, currentY = startY;
    let stepGuard = 0;
    const visited = new Set();

    while(stepGuard++ < 100){
      const posKey = `${currentX},${currentY}`;
      if(visited.has(posKey)) return {success:false, message:'æ£€æµ‹åˆ°å¾ªç¯'};
      visited.add(posKey);

      const portal = findOtherOfType(encounteredType, currentX, currentY);
      if(!portal) return {success:false, message:`æ‰¾ä¸åˆ°é…å¯¹`};

      if(portal.x === originX && portal.y === originY && potentialSwapPortal){
        return {
          success: true, swap: true,
          swapPortalX: potentialSwapPortal.x,
          swapPortalY: potentialSwapPortal.y,
          swapPortalType: potentialSwapPortal.type,
          finalX: potentialSwapPortal.x,
          finalY: potentialSwapPortal.y
        };
      }

      let landX = portal.x + dir.x;
      let landY = portal.y + dir.y;

      if(!inside(landX, landY)){
        const oppX = portal.x - dir.x;
        const oppY = portal.y - dir.y;
        if(!inside(oppX, oppY)) return {success:false, message:'è¾¹ç•Œé˜»æŒ¡'};

        const oppVal = board[oppY][oppX];
        if(oppVal === 0){
          movePiece(portal.x, portal.y, oppX, oppY);
          landX = portal.x; landY = portal.y;
        } else if(oppVal === encounteredType){
          board[portal.y][portal.x] = 0;
          board[oppY][oppX] = 0;
          landX = portal.x; landY = portal.y;
        } else {
          const portalType = board[portal.y][portal.x];
          const reverseDir = {x: -dir.x, y: -dir.y};
          const portalTargetX = portal.x + reverseDir.x;
          const portalTargetY = portal.y + reverseDir.y;
          
          if(!inside(portalTargetX, portalTargetY)) return {success:false, message:'ä¼ é€é—¨æ— æ³•è…¾ç©ºé—´'};
          const portalTargetVal = board[portalTargetY][portalTargetX];
          if(portalTargetVal === 0) return {success:false, message:'åæ–¹å‘æ˜¯ç©ºæ ¼'};
          
          const portalKey = `${portal.x},${portal.y}`;
          if(movingBlockSet.has(portalKey)) return {success:false, message:'æ£€æµ‹åˆ°æ­»é”'};
          
          if(portalTargetVal === portalType){
            board[portal.y][portal.x] = 0;
            board[portalTargetY][portalTargetX] = 0;
            landX = portal.x; landY = portal.y;
          } else {
            const newMovingBlockSet = new Set(movingBlockSet);
            newMovingBlockSet.add(portalKey);
            const swapInfo = {x: portal.x, y: portal.y, type: portalType};
            
            const portalMoveResult = resolveTeleportChain(
              portal.x, portal.y, portalType,
              portalTargetX, portalTargetY,
              reverseDir, depth + 1, newMovingBlockSet,
              originX, originY, swapInfo
            );
            
            if(!portalMoveResult.success) return portalMoveResult;
            if(portalMoveResult.swap) return portalMoveResult;
            
            if(portalMoveResult.eliminated){
              landX = portal.x; landY = portal.y;
            } else {
              board[portal.y][portal.x] = 0;
              board[portalMoveResult.finalY][portalMoveResult.finalX] = portalType;
              landX = portal.x; landY = portal.y;
            }
          }
        }
      }

      if(inside(landX, landY)){
        const landingVal = board[landY][landX];
        if(landingVal === 0) return {success:true, finalX: landX, finalY: landY};
        
        if(landingVal === movingType){
          if(landX === movingX && landY === movingY) return {success:false, message:'å›åˆ°èµ·ç‚¹'};
          board[landY][landX] = 0;
          board[movingY][movingX] = 0;
          return {success:true, eliminated:true};
        }
        
        encounteredType = landingVal;
        currentX = landX; currentY = landY;
      }
    }
    return {success:false, message:'è¶…å‡ºæœ€å¤§é“¾é•¿åº¦'};
  }

  // ========== è™šæ‹Ÿæ–¹å‘é”®æ§åˆ¶ ==========
  function setupVirtualControls() {
    const upBtn = document.getElementById('upBtn');
    const leftBtn = document.getElementById('leftBtn');
    const downBtn = document.getElementById('downBtn');
    const rightBtn = document.getElementById('rightBtn');
    
    // æ·»åŠ è§¦æ‘¸å’Œé¼ æ ‡äº‹ä»¶
    [upBtn, leftBtn, downBtn, rightBtn].forEach(btn => {
      // è§¦æ‘¸äº‹ä»¶
      btn.addEventListener('touchstart', (e) => {
        e.preventDefault();
        handleDirectionPress(btn.dataset.key);
      });
      
      // é¼ æ ‡äº‹ä»¶
      btn.addEventListener('mousedown', () => {
        handleDirectionPress(btn.dataset.key);
      });
    });
    
    // è®¾ç½®æŒ‰é’®çš„data-keyå±æ€§
    upBtn.dataset.key = 'ArrowUp';
    leftBtn.dataset.key = 'ArrowLeft';
    downBtn.dataset.key = 'ArrowDown';
    rightBtn.dataset.key = 'ArrowRight';
  }
  
  function handleDirectionPress(key) {
    if (DIRS[key]) {
      slideSelected(key);
    }
  }

  // ========== åˆå§‹åŒ– ==========
  window.addEventListener('keydown', (e)=>{
    if(DIRS[e.key]){
      e.preventDefault();
      slideSelected(e.key);
    }
  });

  // åˆå§‹åŒ–
  resetRandom();
  setupVirtualControls();
</script>
</body>
</html>