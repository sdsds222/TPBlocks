<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<title>TPBlocks</title>
<style>
  body { font-family: system-ui, -apple-system, "Segoe UI", Arial; display:flex; flex-direction:column; align-items:center; gap:16px; padding:20px; background:#f7f7f7; margin:0; }
  h1 { margin:0; font-size:20px; }
  .mode-indicator { font-size:16px; font-weight:600; color:#666; }
  .board { display:grid; grid-template-columns: repeat(5, 64px); grid-template-rows: repeat(5, 64px); gap:6px; position:relative; }
  .cell { width:64px; height:64px; border-radius:10px; display:flex; align-items:center; justify-content:center; font-weight:700; font-size:18px; cursor:pointer; background:#e6e6e6; color:#fff; box-shadow: inset 0 0 0 2px #ddd; transition: transform 0.1s; position:relative; }
  .cell:hover { transform: scale(1.05); }
  .cell.empty { color:#999; background:#f0f0f0; box-shadow: inset 0 0 0 2px #e4e4e4; }
  .cell.selected { outline: 3px solid #ff9f1c; }
  
  .animated-block {
    position: absolute;
    width: 64px;
    height: 64px;
    border-radius: 10px;
    display: flex;
    align-items: center;
    justify-content: center;
    font-weight: 700;
    font-size: 18px;
    color: #fff;
    box-shadow: inset 0 0 0 2px rgba(0,0,0,0.1);
    pointer-events: none;
    z-index: 100;
  }
  
  .animating .cell {
    pointer-events: none;
  }
  
  .block-1 { background:#ff6b6b; }
  .block-2 { background:#4ecdc4; }
  .block-3 { background:#ffd166; color:#333; }
  .block-4 { background:#06d6a0; }
  .block-5 { background:#118ab2; }
  .block-6 { background:#8338ec; }
  .block-7 { background:#fb5607; }
  .block-8 { background:#3a86ff; }
  .block-9 { background:#e63946; }
  .block-10 { background:#2a9d8f; }
  .block-11 { background:#f77f00; }
  .block-12 { background:#d62828; }
  .panel { display:flex; gap:8px; flex-wrap:wrap; justify-content:center; max-width:700px; }
  button { padding:10px 16px; border:0; border-radius:8px; background:#999; color:#fff; font-weight:600; cursor:pointer; transition: background 0.2s; font-size:14px; }
  button:hover { background:#777; }
  button:active { background:#2b7 !important; }
  button.secondary { background:#999; }
  button.secondary:hover { background:#777; }
  button.secondary:active { background:#2b7 !important; }
  button.danger { background:#e74; }
  button.danger:hover { background:#c52; }
  button.danger:active { background:#2b7 !important; }
  button.active { background:#2b7 !important; }
  button.active:hover { background:#1a6 !important; }
  button.active:active { background:#2b7 !important; }
  .msg { min-height:28px; color:#333; font-weight:500; font-size:15px; text-align:center; }
  .score { font-size:18px; font-weight:700; color:#2b7; margin:8px 0; }
  
  #nextBlockPreview { box-shadow: 0 2px 6px rgba(0,0,0,0.15); }
  
  .level-list { max-width:500px; background:#fff; border-radius:10px; padding:16px; box-shadow: 0 2px 8px rgba(0,0,0,0.1); max-height:400px; overflow-y:auto; }
  .level-item { padding:12px; background:#f7f7f7; border-radius:8px; margin-bottom:8px; cursor:pointer; transition:all 0.2s; display:flex; justify-content:space-between; align-items:center; }
  .level-item:hover { background:#e0e0e0; transform: translateX(4px); }
  .level-item button { padding:6px 12px; font-size:12px; margin-left:8px; }
  
  .info { max-width:680px; font-size:13px; line-height:1.5; color:#666; background:#fff; padding:10px 14px; border-radius:8px; box-shadow: 0 2px 6px rgba(0,0,0,0.05); margin-top:8px; }
  
  .view { display:none; }
  .view.active { display:flex; flex-direction:column; align-items:center; gap:16px; }
  
  .save-input { padding:10px; border-radius:6px; border:2px solid #ddd; width:250px; font-size:14px; margin-right:8px; }
  
  .virtual-controls {
    display: flex;
    justify-content: center;
    align-items: center;
    gap: 10px;
    padding: 15px;
    background: rgba(255, 255, 255, 0.9);
    border-radius: 20px;
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
    margin-top: 12px;
    margin-bottom: 12px;
    touch-action: none;
  }

  .control-btn {
    width: 50px;
    height: 50px;
    border-radius: 50%;
    background: #2b7;
    color: white;
    border: none;
    font-size: 20px;
    font-weight: bold;
    display: flex;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    transition: all 0.1s;
    box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
    user-select: none;
  }

  .control-btn:active {
    background: #1a6;
    transform: scale(0.95);
    box-shadow: 0 1px 3px rgba(0, 0, 0, 0.2);
  }
  
  .difficulty-selector {
    display: flex;
    gap: 8px;
    margin: 8px 0;
  }
  
  .difficulty-btn {
    padding: 8px 16px;
    border: 2px solid #ddd;
    border-radius: 8px;
    background: #fff;
    color: #666;
    font-weight: 600;
    cursor: pointer;
    transition: all 0.2s;
    font-size: 13px;
  }
  
  .difficulty-btn:hover {
    border-color: #2b7;
    color: #2b7;
  }
  
  .difficulty-btn.active {
    background: #2b7;
    color: #fff;
    border-color: #2b7;
  }
  
  .mode-badge {
    display: inline-block;
    padding: 4px 10px;
    border-radius: 6px;
    font-size: 12px;
    font-weight: 600;
    margin-left: 8px;
  }
  
  .mode-badge.hard {
    background: #e74;
    color: #fff;
  }
  
  .modal-overlay {
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: rgba(0, 0, 0, 0.6);
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: 1000;
    animation: fadeIn 0.3s;
  }
  
  .modal {
    background: white;
    border-radius: 16px;
    padding: 32px;
    box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
    max-width: 400px;
    width: 90%;
    text-align: center;
    animation: slideIn 0.3s;
  }
  
  .modal h2 {
    margin: 0 0 8px 0;
    font-size: 28px;
    color: #2b7;
  }
  
  .modal.gameover h2 {
    color: #e74;
  }
  
  .modal p {
    margin: 8px 0 16px 0;
    font-size: 16px;
    color: #666;
  }
  
  .modal .stats {
    background: #f7f7f7;
    border-radius: 10px;
    padding: 16px;
    margin: 20px 0 0 0;
  }
  
  .modal .stat-item {
    display: flex;
    justify-content: space-between;
    margin: 8px 0;
    font-size: 16px;
  }
  
  .modal .stat-label {
    color: #666;
  }
  
  .modal .stat-value {
    font-weight: 700;
    color: #333;
  }
  
  .modal button {
    margin-top: 0;
    margin-bottom: 16px;
    padding: 12px 24px;
    font-size: 16px;
  }
  
  @keyframes fadeIn {
    from { opacity: 0; }
    to { opacity: 1; }
  }
  
  @keyframes slideIn {
    from {
      transform: translateY(-20px);
      opacity: 0;
    }
    to {
      transform: translateY(0);
      opacity: 1;
    }
  }
</style>
</head>
<body>
  <h1>TPBlocks</h1>
  <div class="mode-indicator" id="modeIndicator">Game Mode</div>

  <div class="panel">
    <button id="playModeBtn" class="active">Game Mode</button>
    <button id="endlessModeBtn" class="secondary">Endless Mode</button>
    <button id="editorModeBtn" class="secondary">Level Editor</button>
    <button id="loadLevelBtn" class="secondary">Load Level</button>
  </div>

  <div id="playView" class="view active">
    <div class="panel">
      <button id="resetBtn">Random Level</button>
      <button id="presetBtn" class="secondary">Example Level</button>
      <button id="hardModeBtn" class="secondary">Hard Mode: Off</button>
    </div>
    <div class="score" id="playScore">Moves: 0 | Remaining: 5 pairs</div>
    <div id="playBoard" class="board"></div>
    <div id="playControls" class="virtual-controls">
      <button class="control-btn" data-key="ArrowUp">↑</button>
      <button class="control-btn" data-key="ArrowDown">↓</button>
      <button class="control-btn" data-key="ArrowLeft">←</button>
      <button class="control-btn" data-key="ArrowRight">→</button>
    </div>
    <div id="playMsg" class="msg"></div>
    <div class="info">
      <b>How to Play:</b> Click a block to select it, use arrow keys to move. Blocks can teleport through portals. Same numbered blocks eliminate when sliding adjacent.<br>
      <b>Hard Mode:</b> Teleportation fails when portal at boundary cannot make space.
    </div>
  </div>

  <div id="endlessView" class="view">
    <div class="difficulty-selector">
      <button class="difficulty-btn active" data-steps="2">Easy (2 move refresh)</button>
      <button class="difficulty-btn" data-steps="3">Normal (3 move refresh)</button>
    </div>
    <div class="panel">
      <button id="endlessStartBtn">Start Game</button>
      <button id="endlessRestartBtn" class="secondary" style="display:none;">Restart</button>
      <button id="endlessHardModeBtn" class="secondary">Hard Mode: Off</button>
    </div>
    <div class="score" id="endlessScore">Moves: 0 | Eliminated: 0 pairs</div>
    <div id="endlessBoard" class="board"></div>
    <div id="endlessControls" class="virtual-controls">
      <button class="control-btn" data-key="ArrowUp">↑</button>
      <button class="control-btn" data-key="ArrowDown">↓</button>
      <button class="control-btn" data-key="ArrowLeft">←</button>
      <button class="control-btn" data-key="ArrowRight">→</button>
    </div>
    <div id="endlessMsg" class="msg"></div>
    <div class="info">
      <b>Endless Mode:</b> New pair added every few moves. Survive as long as possible for higher score!
    </div>
  </div>

  <div id="editorView" class="view">
    <div class="panel">
      <button id="placeBtn">Place Block</button>
      <button id="deleteBtn">Delete Block</button>
      <button id="clearBtn" class="danger">Clear Board</button>
    </div>
    <div style="margin: 8px 0; font-size: 14px; color: #666;">
      <span>Next Block:</span>
      <span id="nextBlockPreview" style="display:inline-block; width:32px; height:32px; border-radius:6px; text-align:center; line-height:32px; color:#fff; font-weight:700; margin-left:8px;"></span>
      <span id="nextBlockText" style="margin-left:8px; font-weight:600;"></span>
      <span id="capacityInfo" style="margin-left:16px; font-weight:600; color:#666;"></span>
    </div>
    <div class="panel">
      <button id="testBtn">▶ Test Level</button>
      <button id="saveBtn">Save Level</button>
      <button id="backToEditBtn" class="secondary" style="display:none;">Back to Edit</button>
      <button id="editorHardModeBtn" class="secondary" style="display:none;">Hard Mode: Off</button>
    </div>
    <div class="score" id="editorScore" style="display:none;">Moves: 0 | Remaining: 0 pairs</div>
    <div id="editorBoard" class="board"></div>
    <div id="editorControls" class="virtual-controls">
      <button class="control-btn" data-key="ArrowUp">↑</button>
      <button class="control-btn" data-key="ArrowDown">↓</button>
      <button class="control-btn" data-key="ArrowLeft">←</button>
      <button class="control-btn" data-key="ArrowRight">→</button>
    </div>
    <div id="editorMsg" class="msg"></div>
    <div id="saveArea" style="display:none; margin-top:8px;">
      <input type="text" id="levelName" class="save-input" placeholder="Enter level name...">
      <button onclick="saveLevelWithName()">Confirm</button>
      <button onclick="cancelSave()" class="secondary">Cancel</button>
    </div>
    <div class="info">
      <b>Editor:</b> Click "Place Block", then click board twice to place a matching pair.
    </div>
  </div>

  <div id="loadView" class="view">
    <div class="level-list" id="levelList"></div>
    <div class="info">
      <b>Tip:</b> Click a level to load it into Game Mode.
    </div>
  </div>

<script>
  const SIZE = 5;
  const DIRS = {
    ArrowUp: {x:0, y:-1}, ArrowDown: {x:0, y:1},
    ArrowLeft: {x:-1, y:0}, ArrowRight: {x:1, y:0}
  };

  let currentView = 'play';
  let currentMode = 'play';
  let board = Array.from({length:SIZE}, ()=> Array(SIZE).fill(0));
  let selected = null;
  let blocksRemaining = 0;
  let isAnimating = false;
  
  let editorMode = 'place';
  let nextBlockNumber = 1;
  let placingBlock = null;
  
  let endlessMoves = 0;
  let endlessNextType = 1;
  let endlessGameOver = false;
  let movesUntilNewBlocks = 0;
  let endlessRefreshSteps = 2;
  let endlessEliminated = 0;
  
  let playMoves = 0;
  let editorMoves = 0;
  let playEliminated = 0;
  let editorEliminated = 0;
  
  let playHardMode = false;
  let endlessHardMode = false;
  let editorHardMode = false;
  
  let playStartTime = null;
  let editorStartTime = null;
  let endlessStartTime = null;

  function inside(x,y){ return x>=0 && x<SIZE && y>=0 && y<SIZE; }

  function switchView(view, preserveBoard = false){
    document.querySelectorAll('.view').forEach(v => v.classList.remove('active'));
    document.getElementById(view + 'View').classList.add('active');
    currentView = view;
    
    const allBtns = document.querySelectorAll('#playModeBtn, #endlessModeBtn, #editorModeBtn, #loadLevelBtn');
    allBtns.forEach(btn => {
      btn.classList.remove('active');
      btn.classList.add('secondary');
    });
    
    const btnMap = {play: 'playModeBtn', endless: 'endlessModeBtn', editor: 'editorModeBtn', load: 'loadLevelBtn'};
    const activeBtn = document.getElementById(btnMap[view]);
    activeBtn.classList.remove('secondary');
    activeBtn.classList.add('active');
    
    const indicators = {play: 'Game Mode', endless: 'Endless Mode', editor: 'Level Editor', load: 'Load Level'};
    document.getElementById('modeIndicator').textContent = indicators[view];
    
    if (view === 'play') {
      currentMode = 'play';
      if(!preserveBoard){ resetRandom(); } 
      else { renderBoard('play'); }
    } else if (view === 'endless') {
      currentMode = 'endless';
    } else if (view === 'editor') {
      currentMode = 'editor';
      initEditor();
    }
  }

  document.getElementById('playModeBtn').onclick = () => switchView('play');
  document.getElementById('endlessModeBtn').onclick = () => {
    switchView('endless');
    showMsg('endless', 'Select difficulty and click "Start Game"');
  };
  document.getElementById('editorModeBtn').onclick = () => switchView('editor');
  document.getElementById('loadLevelBtn').onclick = () => {
    switchView('load');
    loadSavedLevels();
  };

  document.getElementById('hardModeBtn').onclick = () => {
    playHardMode = !playHardMode;
    updateHardModeButton('hardModeBtn', playHardMode);
    playMoves = 0;
    playEliminated = 0;
    playStartTime = null;
    updatePlayScore();
  };
  
  document.getElementById('endlessHardModeBtn').onclick = () => {
    endlessHardMode = !endlessHardMode;
    updateHardModeButton('endlessHardModeBtn', endlessHardMode);
  };
  
  document.getElementById('editorHardModeBtn').onclick = () => {
    editorHardMode = !editorHardMode;
    updateHardModeButton('editorHardModeBtn', editorHardMode);
    editorMoves = 0;
    editorEliminated = 0;
    editorStartTime = null;
    updateEditorScore();
  };
  
  function updateHardModeButton(btnId, isHard) {
    const btn = document.getElementById(btnId);
    btn.textContent = `Hard Mode: ${isHard ? 'On' : 'Off'}`;
    btn.className = isHard ? 'danger' : 'secondary';
  }
  
  document.querySelectorAll('.difficulty-btn').forEach(btn => {
    btn.onclick = () => {
      document.querySelectorAll('.difficulty-btn').forEach(b => b.classList.remove('active'));
      btn.classList.add('active');
      endlessRefreshSteps = parseInt(btn.dataset.steps);
    };
  });

  function resetRandom(){
    board = Array.from({length:SIZE}, ()=> Array(SIZE).fill(0));
    const pairs = [1,2,3,4,5];
    pairs.forEach(t => placeRandomPair(t));
    selected = null;
    playMoves = 0;
    playEliminated = 0;
    playStartTime = null;
    updatePlayScore();
    renderBoard('play');
    showMsg('play', 'Random level generated');
  }

  function loadPreset(){
    board = Array.from({length:SIZE}, ()=> Array(SIZE).fill(0));
    board[0][2]=1; board[0][3]=1;
    board[0][0]=2; board[0][1]=2;
    board[2][2]=3; board[2][4]=3;
    board[1][1]=4; board[3][3]=4;
    board[4][4]=5; board[0][4]=5;
    selected = null;
    playMoves = 0;
    playEliminated = 0;
    playStartTime = null;
    updatePlayScore();
    renderBoard('play');
    showMsg('play', 'Example level loaded');
  }

  function placeRandomPair(type){
    let placed = 0;
    while(placed < 2){
      const x = Math.floor(Math.random()*SIZE);
      const y = Math.floor(Math.random()*SIZE);
      if(board[y][x] === 0){
        board[y][x] = type;
        placed++;
      }
    }
  }

  document.getElementById('resetBtn').onclick = resetRandom;
  document.getElementById('presetBtn').onclick = loadPreset;
  
  function getRemainingPairs() {
    return countBlocks() / 2;
  }
  
  function formatTime(ms) {
    const seconds = Math.floor(ms / 1000);
    const minutes = Math.floor(seconds / 60);
    const secs = seconds % 60;
    return `${minutes}:${secs.toString().padStart(2, '0')}`;
  }
  
  function updatePlayScore() {
    const remaining = getRemainingPairs();
    const hardBadge = playHardMode ? '<span class="mode-badge hard">Hard</span>' : '';
    document.getElementById('playScore').innerHTML = `Moves: ${playMoves} | Remaining: ${remaining} pairs${hardBadge}`;
  }
  
  function updateEditorScore() {
    const remaining = getRemainingPairs();
    const hardBadge = editorHardMode ? '<span class="mode-badge hard">Hard</span>' : '';
    document.getElementById('editorScore').innerHTML = `Moves: ${editorMoves} | Remaining: ${remaining} pairs${hardBadge}`;
  }

  function startEndless(){
    board = Array.from({length:SIZE}, ()=> Array(SIZE).fill(0));
    placeRandomPair(1);
    placeRandomPair(2);
    placeRandomPair(3);
    endlessMoves = 0;
    endlessEliminated = 0;
    movesUntilNewBlocks = endlessRefreshSteps;
    endlessNextType = 4;
    endlessGameOver = false;
    endlessStartTime = null;
    selected = null;
    currentMode = 'endless';
    document.getElementById('endlessStartBtn').style.display = 'none';
    document.getElementById('endlessRestartBtn').style.display = 'inline-block';
    updateEndlessScore();
    renderBoard('endless');
    showMsg('endless', 'Endless mode started');
  }

  function updateEndlessScore(){
    const hardBadge = endlessHardMode ? '<span class="mode-badge hard">Hard</span>' : '';
    document.getElementById('endlessScore').innerHTML = `Moves: ${endlessMoves} | Eliminated: ${endlessEliminated} pairs (${movesUntilNewBlocks} moves until new blocks)${hardBadge}`;
  }

  function addRandomPairEndless(){
    const emptySpots = [];
    for(let y=0; y<SIZE; y++){
      for(let x=0; x<SIZE; x++){
        if(board[y][x] === 0) emptySpots.push({x, y});
      }
    }
    
    if(emptySpots.length < 2){
      endlessGameOver = true;
      const elapsedTime = endlessStartTime ? Date.now() - endlessStartTime : 0;
      showGameOverModal('endless', endlessMoves, endlessEliminated, elapsedTime);
      return false;
    }
    
    let newType;
    if(endlessNextType <= 12){
      newType = endlessNextType;
      endlessNextType++;
    } else {
      const usedTypes = new Set();
      for(let y=0; y<SIZE; y++){
        for(let x=0; x<SIZE; x++){
          if(board[y][x] > 0) usedTypes.add(board[y][x]);
        }
      }
      let foundReuse = false;
      for(let i=1; i<=12; i++){
        if(!usedTypes.has(i)){
          newType = i;
          foundReuse = true;
          break;
        }
      }
      if(!foundReuse){
        newType = endlessNextType;
        endlessNextType++;
      }
    }
    
    const idx1 = Math.floor(Math.random() * emptySpots.length);
    const spot1 = emptySpots.splice(idx1, 1)[0];
    const idx2 = Math.floor(Math.random() * emptySpots.length);
    const spot2 = emptySpots[idx2];
    
    board[spot1.y][spot1.x] = newType;
    board[spot2.y][spot2.x] = newType;
    
    showMsg('endless', `Added block ${newType}`);
    return true;
  }

  document.getElementById('endlessStartBtn').onclick = startEndless;
  document.getElementById('endlessRestartBtn').onclick = () => {
    document.getElementById('endlessStartBtn').style.display = 'inline-block';
    document.getElementById('endlessRestartBtn').style.display = 'none';
    showMsg('endless', 'Select difficulty and click "Start Game"');
  };

  function initEditor(){
    board = Array.from({length:SIZE}, ()=> Array(SIZE).fill(0));
    selected = null;
    editorMode = 'place';
    nextBlockNumber = 1;
    placingBlock = null;
    editorMoves = 0;
    editorEliminated = 0;
    editorStartTime = null;
    updateEditorButtons();
    updateNextBlockPreview();
    updateCapacityInfo();
    renderBoard('editor');
    showMsg('editor', 'Click "Place Block", then click board twice to place a pair');
  }

  function updateCapacityInfo(){
    const totalCells = SIZE * SIZE;
    const usedCells = countBlocks();
    const maxPairs = Math.floor((totalCells - 1) / 2);
    const currentPairs = usedCells / 2;
    
    const capacityText = document.getElementById('capacityInfo');
    if(capacityText){
      capacityText.textContent = `Capacity: ${currentPairs}/${maxPairs} pairs`;
      if(currentPairs >= maxPairs){
        capacityText.style.color = '#e74';
      } else {
        capacityText.style.color = '#666';
      }
    }
  }

  function canPlaceMoreBlocks(){
    const totalCells = SIZE * SIZE;
    const usedCells = countBlocks();
    return usedCells < (totalCells - 1);
  }

  function updateEditorButtons(){
    const placeBtn = document.getElementById('placeBtn');
    const deleteBtn = document.getElementById('deleteBtn');
    
    placeBtn.classList.remove('active');
    deleteBtn.classList.remove('active');
    
    if(editorMode === 'place'){
      placeBtn.classList.add('active');
    } else {
      deleteBtn.classList.add('active');
    }
    
    if(!canPlaceMoreBlocks()){
      placeBtn.disabled = true;
      placeBtn.style.opacity = '0.5';
    } else {
      placeBtn.disabled = false;
      placeBtn.style.opacity = '1';
    }
  }

  function updateNextBlockPreview(){
    const preview = document.getElementById('nextBlockPreview');
    const text = document.getElementById('nextBlockText');
    
    if(nextBlockNumber > 12){
      preview.style.background = '#999';
      preview.textContent = nextBlockNumber;
      text.textContent = `Block ${nextBlockNumber}`;
    } else {
      preview.className = 'block-' + nextBlockNumber;
      preview.textContent = nextBlockNumber;
      text.textContent = `Block ${nextBlockNumber}`;
    }
  }

  function getNextBlockNumber(){
    let maxNum = 0;
    for(let y=0; y<SIZE; y++){
      for(let x=0; x<SIZE; x++){
        if(board[y][x] > maxNum) maxNum = board[y][x];
      }
    }
    return maxNum + 1;
  }

  document.getElementById('placeBtn').onclick = () => {
    if(!canPlaceMoreBlocks()){
      showMsg('editor', 'Board is full');
      return;
    }
    editorMode = 'place';
    placingBlock = null;
    updateEditorButtons();
    showMsg('editor', 'Place mode');
  };

  document.getElementById('deleteBtn').onclick = () => {
    editorMode = 'delete';
    placingBlock = null;
    updateEditorButtons();
    showMsg('editor', 'Delete mode');
  };

  document.getElementById('clearBtn').onclick = () => {
    if(countBlocks() > 0 && !confirm('Clear entire board?')) return;
    board = Array.from({length:SIZE}, ()=> Array(SIZE).fill(0));
    editorMode = 'place';
    placingBlock = null;
    nextBlockNumber = 1;
    updateEditorButtons();
    updateNextBlockPreview();
    updateCapacityInfo();
    renderBoard('editor');
    showMsg('editor', 'Board cleared');
  };

  document.getElementById('testBtn').onclick = () => {
    const typeCounts = {};
    for(let y=0; y<SIZE; y++){
      for(let x=0; x<SIZE; x++){
        const v = board[y][x];
        if(v > 0) typeCounts[v] = (typeCounts[v] || 0) + 1;
      }
    }
    
    for(let type in typeCounts){
      if(typeCounts[type] !== 2){
        showMsg('editor', `Error: Block ${type} has only ${typeCounts[type]} piece(s)`);
        return;
      }
    }
    
    if(countBlocks() === 0){
      showMsg('editor', 'Board is empty');
      return;
    }
    
    currentMode = 'editorTest';
    selected = null;
    editorMoves = 0;
    editorEliminated = 0;
    editorStartTime = null;
    document.getElementById('placeBtn').style.display = 'none';
    document.getElementById('deleteBtn').style.display = 'none';
    document.getElementById('testBtn').style.display = 'none';
    document.getElementById('saveBtn').style.display = 'none';
    document.getElementById('nextBlockPreview').parentElement.style.display = 'none';
    document.getElementById('backToEditBtn').style.display = 'inline-block';
    document.getElementById('editorHardModeBtn').style.display = 'inline-block';
    document.getElementById('clearBtn').style.display = 'none';
    document.getElementById('editorScore').style.display = 'block';
    updateEditorScore();
    
    renderBoard('editor');
    showMsg('editor', 'Test mode');
  };

  document.getElementById('backToEditBtn').onclick = () => {
    document.getElementById('placeBtn').style.display = 'inline-block';
    document.getElementById('deleteBtn').style.display = 'inline-block';
    document.getElementById('testBtn').style.display = 'inline-block';
    document.getElementById('saveBtn').style.display = 'inline-block';
    document.getElementById('nextBlockPreview').parentElement.style.display = 'block';
    document.getElementById('backToEditBtn').style.display = 'none';
    document.getElementById('editorHardModeBtn').style.display = 'none';
    document.getElementById('clearBtn').style.display = 'inline-block';
    document.getElementById('editorScore').style.display = 'none';
    
    currentMode = 'editor';
    updateEditorButtons();
    updateNextBlockPreview();
    updateCapacityInfo();
    renderBoard('editor');
    showMsg('editor', 'Back to edit mode');
  };

  document.getElementById('saveBtn').onclick = () => {
    const typeCounts = {};
    for(let y=0; y<SIZE; y++){
      for(let x=0; x<SIZE; x++){
        const v = board[y][x];
        if(v > 0) typeCounts[v] = (typeCounts[v] || 0) + 1;
      }
    }
    
    for(let type in typeCounts){
      if(typeCounts[type] !== 2){
        showMsg('editor', `Error: Block ${type} has only ${typeCounts[type]} piece(s)`);
        return;
      }
    }
    
    if(countBlocks() === 0){
      showMsg('editor', 'Board is empty');
      return;
    }
    document.getElementById('saveArea').style.display = 'block';
    document.getElementById('levelName').focus();
  };

  window.saveLevelWithName = function(){
    const name = document.getElementById('levelName').value.trim();
    if(!name){
      showMsg('editor', 'Please enter level name');
      return;
    }
    
    const levels = JSON.parse(localStorage.getItem('customLevels') || '[]');
    levels.push({
      id: Date.now(),
      name: name,
      board: JSON.stringify(board),
      createdAt: new Date().toLocaleString('en-US')
    });
    localStorage.setItem('customLevels', JSON.stringify(levels));
    
    document.getElementById('saveArea').style.display = 'none';
    document.getElementById('levelName').value = '';
    showMsg('editor', `Level "${name}" saved`);
  };

  window.cancelSave = function(){
    document.getElementById('saveArea').style.display = 'none';
    document.getElementById('levelName').value = '';
  };

  function loadSavedLevels(){
    const levels = JSON.parse(localStorage.getItem('customLevels') || '[]');
    const listEl = document.getElementById('levelList');
    
    if(levels.length === 0){
      listEl.innerHTML = '<div style="text-align:center; color:#999; padding:40px;">No saved levels</div>';
      return;
    }
    
    listEl.innerHTML = '<h3 style="margin:0 0 12px 0; font-size:16px;">Saved Levels</h3>';
    levels.forEach(level => {
      const item = document.createElement('div');
      item.className = 'level-item';
      item.innerHTML = `
        <div>
          <div style="font-weight:600;">${level.name}</div>
          <div style="font-size:11px; color:#999;">${level.createdAt}</div>
        </div>
        <div>
          <button class="secondary" onclick="loadCustomLevel(${level.id})">Load</button>
          <button class="danger" onclick="deleteLevel(${level.id})">Delete</button>
        </div>
      `;
      listEl.appendChild(item);
    });
  }

  window.loadCustomLevel = function(id){
    const levels = JSON.parse(localStorage.getItem('customLevels') || '[]');
    const level = levels.find(l => l.id === id);
    if(level){
      board = JSON.parse(level.board);
      selected = null;
      playMoves = 0;
      playEliminated = 0;
      playStartTime = null;
      switchView('play', true);
      currentMode = 'play';
      updatePlayScore();
      renderBoard('play');
      showMsg('play', `Loaded level: ${level.name}`);
    }
  };

  window.deleteLevel = function(id){
    if(!confirm('Delete this level?')) return;
    let levels = JSON.parse(localStorage.getItem('customLevels') || '[]');
    levels = levels.filter(l => l.id !== id);
    localStorage.setItem('customLevels', JSON.stringify(levels));
    loadSavedLevels();
  };

  function renderBoard(mode){
    const boardEl = document.getElementById(mode + 'Board');
    boardEl.innerHTML = '';
    
    for(let y=0; y<SIZE; y++){
      for(let x=0; x<SIZE; x++){
        const v = board[y][x];
        const cell = document.createElement('div');
        cell.className = 'cell';
        if(v===0) cell.classList.add('empty');
        else cell.classList.add('block-'+v);
        cell.textContent = v===0 ? '' : String(v);
        
        if(selected && selected.x===x && selected.y===y && currentMode !== 'editor'){
          cell.classList.add('selected');
        }
        
        cell.onclick = () => handleCellClick(x, y, mode);
        boardEl.appendChild(cell);
      }
    }
    blocksRemaining = countBlocks();
  }

  function handleCellClick(x, y, mode){
    if(currentMode === 'editor'){
      if(editorMode === 'delete'){
        if(board[y][x] !== 0){
          const deletedType = board[y][x];
          for(let dy=0; dy<SIZE; dy++){
            for(let dx=0; dx<SIZE; dx++){
              if(board[dy][dx] === deletedType){
                board[dy][dx] = 0;
              }
            }
          }
          showMsg('editor', `Deleted block ${deletedType}`);
          nextBlockNumber = getNextBlockNumber();
          updateNextBlockPreview();
          updateCapacityInfo();
          updateEditorButtons();
          renderBoard('editor');
        }
      } else {
        if(board[y][x] !== 0){
          showMsg('editor', 'Cell already has a block');
          return;
        }
        
        if(!canPlaceMoreBlocks() && !placingBlock){
          showMsg('editor', 'Board is full');
          return;
        }
        
        if(!placingBlock){
          placingBlock = {type: nextBlockNumber, firstPos: {x, y}};
          board[y][x] = nextBlockNumber;
          showMsg('editor', `Placed first block ${nextBlockNumber}`);
          renderBoard('editor');
        } else {
          board[y][x] = placingBlock.type;
          showMsg('editor', `Completed pair for block ${placingBlock.type}`);
          nextBlockNumber++;
          updateNextBlockPreview();
          updateCapacityInfo();
          updateEditorButtons();
          placingBlock = null;
          renderBoard('editor');
        }
      }
    } else {
      const v = board[y][x];
      if(v===0){ 
        selected=null;
        renderBoard(mode);
        return;
      }
      selected={x,y};
      renderBoard(mode);
      showMsg(mode, `Selected block ${v}`);
    }
  }

  function showMsg(mode, text){
    document.getElementById(mode + 'Msg').textContent = text;
  }

  function countBlocks(){
    let c=0;
    for(let y=0;y<SIZE;y++) for(let x=0;x<SIZE;x++) if(board[y][x]>0) c++;
    return c;
  }

  function findOtherOfType(type, excludeX, excludeY){
    for(let y=0;y<SIZE;y++){
      for(let x=0;x<SIZE;x++){
        if(board[y][x]===type && !(x===excludeX && y===excludeY)) return {x,y};
      }
    }
    return null;
  }

  function movePiece(fromX,fromY,toX,toY){
    board[toY][toX] = board[fromY][fromX];
    board[fromY][fromX] = 0;
  }
  
  function checkDeadlock() {
    for(let y = 0; y < SIZE; y++) {
      for(let x = 0; x < SIZE; x++) {
        if(board[y][x] === 0) continue;
        
        const type = board[y][x];
        for(let dirKey in DIRS) {
          const dir = DIRS[dirKey];
          const nx = x + dir.x;
          const ny = y + dir.y;
          
          if(inside(nx, ny) && board[ny][nx] !== 0) {
            return false;
          }
        }
      }
    }
    return true;
  }
  
  function showVictoryModal(mode, moves, eliminated, elapsedTime) {
    const overlay = document.createElement('div');
    overlay.className = 'modal-overlay';
    
    const modal = document.createElement('div');
    modal.className = 'modal';
    
    const timeStr = formatTime(elapsedTime);
    const modeText = mode === 'play' ? (playHardMode ? ' [Hard Mode]' : '') : 
                     mode === 'editorTest' ? (editorHardMode ? ' [Hard Mode]' : '') : '';
    
    modal.innerHTML = `
      <h2>Victory${modeText}</h2>
      <p>Successfully eliminated all blocks!</p>
      <button onclick="closeModal()">OK</button>
      <div class="stats">
        <div class="stat-item">
          <span class="stat-label">Time:</span>
          <span class="stat-value">${timeStr}</span>
        </div>
        <div class="stat-item">
          <span class="stat-label">Eliminated:</span>
          <span class="stat-value">${eliminated} pairs</span>
        </div>
        <div class="stat-item">
          <span class="stat-label">Moves:</span>
          <span class="stat-value">${moves}</span>
        </div>
      </div>
    `;
    
    overlay.appendChild(modal);
    document.body.appendChild(overlay);
    
    window.closeModal = function() {
      overlay.remove();
    };
  }
  
  function showGameOverModal(mode, moves, eliminated, elapsedTime) {
    const overlay = document.createElement('div');
    overlay.className = 'modal-overlay';
    
    const modal = document.createElement('div');
    modal.className = 'modal gameover';
    
    const timeStr = formatTime(elapsedTime);
    
    let reason = '';
    if(mode === 'endless') {
      reason = '<p>Cannot add new blocks!</p>';
    } else {
      reason = '<p>No valid moves available!</p>';
    }
    
    const modeText = mode === 'play' ? (playHardMode ? ' [Hard Mode]' : '') : 
                     mode === 'editorTest' ? (editorHardMode ? ' [Hard Mode]' : '') :
                     mode === 'endless' ? (endlessHardMode ? ' [Hard Mode]' : '') : '';
    
    modal.innerHTML = `
      <h2>Game Over${modeText}</h2>
      ${reason}
      <button onclick="closeModal()">OK</button>
      <div class="stats">
        <div class="stat-item">
          <span class="stat-label">Time:</span>
          <span class="stat-value">${timeStr}</span>
        </div>
        <div class="stat-item">
          <span class="stat-label">Eliminated:</span>
          <span class="stat-value">${eliminated} pairs</span>
        </div>
        <div class="stat-item">
          <span class="stat-label">Moves:</span>
          <span class="stat-value">${moves}</span>
        </div>
      </div>
    `;
    
    overlay.appendChild(modal);
    document.body.appendChild(overlay);
    
    window.closeModal = function() {
      overlay.remove();
    };
  }

  function getCellPosition(x, y, mode) {
    const boardEl = document.getElementById(mode + 'Board');
    const index = y * SIZE + x;
    const cell = boardEl.children[index];
    if (!cell) return null;
    const rect = cell.getBoundingClientRect();
    const boardRect = boardEl.getBoundingClientRect();
    return {
      left: rect.left - boardRect.left,
      top: rect.top - boardRect.top
    };
  }
  
  function createAnimatedBlock(x, y, blockType, mode) {
    const boardEl = document.getElementById(mode + 'Board');
    const index = y * SIZE + x;
    const cell = boardEl.children[index];
    
    const pos = getCellPosition(x, y, mode);
    if (!pos) return null;
    
    if (cell && cell.classList.contains('cell') && !cell.classList.contains('empty')) {
      for (let i = 1; i <= 20; i++) {
        cell.classList.remove('block-' + i);
      }
      cell.classList.add('empty');
      cell.textContent = '';
    }
    
    const block = document.createElement('div');
    block.className = 'animated-block block-' + blockType;
    block.textContent = blockType;
    block.style.left = pos.left + 'px';
    block.style.top = pos.top + 'px';
    
    boardEl.appendChild(block);
    return block;
  }
  
  function animateSlide(block, fromX, fromY, toX, toY, mode, duration = 200) {
    return new Promise(resolve => {
      const toPos = getCellPosition(toX, toY, mode);
      if (!toPos) {
        resolve();
        return;
      }
      
      block.style.transition = `all ${duration}ms ease-in-out`;
      block.style.left = toPos.left + 'px';
      block.style.top = toPos.top + 'px';
      
      setTimeout(resolve, duration);
    });
  }
  
  function animateSlideInto(block, fromX, fromY, toX, toY, mode, duration = 200) {
    return new Promise(resolve => {
      const toPos = getCellPosition(toX, toY, mode);
      if (!toPos) {
        resolve();
        return;
      }
      
      block.style.transition = `all ${duration}ms ease-in-out`;
      block.style.left = toPos.left + 'px';
      block.style.top = toPos.top + 'px';
      block.style.transform = 'scale(0.7)';
      block.style.opacity = '0.8';
      block.style.zIndex = '50';
      
      setTimeout(resolve, duration);
    });
  }
  
  function animateSlideOut(block, fromX, fromY, toX, toY, mode, duration = 200) {
    return new Promise(resolve => {
      block.style.transform = 'scale(1)';
      block.style.opacity = '1';
      block.style.zIndex = '100';
      
      const toPos = getCellPosition(toX, toY, mode);
      if (!toPos) {
        resolve();
        return;
      }
      
      setTimeout(() => {
        block.style.transition = `all ${duration}ms ease-out`;
        block.style.left = toPos.left + 'px';
        block.style.top = toPos.top + 'px';
        
        setTimeout(resolve, duration);
      }, 50);
    });
  }
  
  function animateTeleportInto(block, toX, toY, mode, duration = 150) {
    return new Promise(resolve => {
      const toPos = getCellPosition(toX, toY, mode);
      if (!toPos) {
        resolve();
        return;
      }
      
      block.style.transition = `all ${duration}ms ease-in-out`;
      block.style.left = toPos.left + 'px';
      block.style.top = toPos.top + 'px';
      
      setTimeout(resolve, duration);
    });
  }
  
  function animateEliminate(block, duration = 300) {
    return new Promise(resolve => {
      block.style.transition = `all ${duration}ms ease-in`;
      block.style.transform = 'scale(1.2)';
      block.style.opacity = '0';
      
      setTimeout(() => {
        block.remove();
        resolve();
      }, duration);
    });
  }
  
  async function executeAnimationSequence(actionSequence, mode) {
    const boardEl = document.getElementById(mode + 'Board');
    boardEl.classList.add('animating');
    
    const animatedBlocks = new Map();
    
    for (const action of actionSequence) {
      switch(action.type) {
        case 'slide': {
          let block = animatedBlocks.get(action.blockType);
          if (!block) {
            block = createAnimatedBlock(action.fromX, action.fromY, action.blockType, mode);
            if (block) animatedBlocks.set(action.blockType, block);
          }
          if (block) {
            await animateSlide(block, action.fromX, action.fromY, action.toX, action.toY, mode);
          }
          break;
        }
        
        case 'slideInto': {
          let block = animatedBlocks.get(action.blockType);
          if (!block) {
            block = createAnimatedBlock(action.fromX, action.fromY, action.blockType, mode);
            if (block) animatedBlocks.set(action.blockType, block);
          }
          if (block) {
            await animateSlideInto(block, action.fromX, action.fromY, action.toX, action.toY, mode);
          }
          break;
        }
        
        case 'slideOut': {
          const block = animatedBlocks.get(action.blockType);
          if (block) {
            await animateSlideOut(block, action.fromX, action.fromY, action.toX, action.toY, mode);
          }
          break;
        }
        
        case 'teleport': {
          const block = animatedBlocks.get(action.blockType);
          if (block) {
            await animateTeleportInto(block, action.toX, action.toY, mode, 100);
          }
          break;
        }
        
        case 'teleportInto': {
          const block = animatedBlocks.get(action.blockType);
          if (block) {
            await animateTeleportInto(block, action.toX, action.toY, mode);
          }
          break;
        }
        
        case 'slideOutAndEliminate': {
          const block = animatedBlocks.get(action.blockType);
          if (block) {
            await animateSlideOut(block, action.fromX, action.fromY, action.toX, action.toY, mode, 150);
            await animateEliminate(block);
            animatedBlocks.delete(action.blockType);
          }
          break;
        }
        
        case 'eliminate': {
          const block = animatedBlocks.get(action.blockType);
          if (block) {
            await animateEliminate(block);
            animatedBlocks.delete(action.blockType);
          }
          break;
        }
        
        case 'portalMakeSpace': {
          const portalBlock = createAnimatedBlock(action.portalX, action.portalY, action.portalType, mode);
          if (portalBlock) {
            await animateSlide(portalBlock, action.portalX, action.portalY, action.toX, action.toY, mode, 150);
            
            const boardEl = document.getElementById(mode + 'Board');
            const targetIndex = action.toY * SIZE + action.toX;
            const targetCell = boardEl.children[targetIndex];
            if (targetCell) {
              targetCell.classList.remove('empty');
              targetCell.classList.add('block-' + action.portalType);
              targetCell.textContent = action.portalType;
            }
            
            portalBlock.remove();
          }
          break;
        }
        
        case 'portalEliminate': {
          const block1 = createAnimatedBlock(action.x1, action.y1, action.blockType, mode);
          const block2 = createAnimatedBlock(action.x2, action.y2, action.blockType, mode);
          
          const promises = [];
          if (block1) promises.push(animateEliminate(block1, 200));
          if (block2) promises.push(animateEliminate(block2, 200));
          
          await Promise.all(promises);
          break;
        }
        
        case 'portalPushEliminate': {
          const portalBlock = createAnimatedBlock(action.portalX, action.portalY, action.portalType, mode);
          if (portalBlock) {
            await animateSlide(portalBlock, action.portalX, action.portalY, action.targetX, action.targetY, mode, 150);
            await animateEliminate(portalBlock, 200);
          }
          break;
        }
        
        case 'swap': {
          const movingBlock = animatedBlocks.get(action.movingType);
          const swapBlock = createAnimatedBlock(action.swapX, action.swapY, action.swapType, mode);
          
          if (movingBlock && swapBlock) {
            await Promise.all([
              animateSlide(movingBlock, action.movingX, action.movingY, action.swapX, action.swapY, mode, 250),
              animateSlide(swapBlock, action.swapX, action.swapY, action.movingX, action.movingY, mode, 250)
            ]);
            movingBlock.remove();
            swapBlock.remove();
          }
          break;
        }
      }
    }
    
    animatedBlocks.forEach(block => block.remove());
    boardEl.classList.remove('animating');
  }

  function slideSelected(dirKey){
    if(!selected) return;
    if(currentMode !== 'play' && currentMode !== 'editorTest' && currentMode !== 'endless') return;
    if(currentMode === 'endless' && endlessGameOver) return;
    if(isAnimating) return;
    
    const dir = DIRS[dirKey];
    if(!dir) return;
    
    const renderMode = currentMode === 'editorTest' ? 'editor' : currentMode;
    const sx = selected.x, sy = selected.y;
    const sType = board[sy][sx];

    const nx = sx + dir.x, ny = sy + dir.y;
    if(!inside(nx,ny)){ showMsg(renderMode, 'Cannot slide out of bounds'); return; }
    if(board[ny][nx]===0){ showMsg(renderMode, 'Cannot slide to empty cell'); return; }

    const neighborType = board[ny][nx];
    
    const isHard = currentMode === 'play' ? playHardMode : 
                   currentMode === 'editorTest' ? editorHardMode : 
                   endlessHardMode;

    if(neighborType === sType){
      isAnimating = true;
      
      if(currentMode === 'play' && !playStartTime) {
        playStartTime = Date.now();
      } else if(currentMode === 'editorTest' && !editorStartTime) {
        editorStartTime = Date.now();
      } else if(currentMode === 'endless' && !endlessStartTime) {
        endlessStartTime = Date.now();
      }
      
      const actionSequence = [
        {type: 'slide', fromX: sx, fromY: sy, toX: nx, toY: ny, blockType: sType},
        {type: 'eliminate', x1: sx, y1: sy, x2: nx, y2: ny, blockType: sType}
      ];
      
      executeAnimationSequence(actionSequence, renderMode).then(() => {
        board[sy][sx] = 0;
        board[ny][nx] = 0;
        selected = null;
        
        incrementMoveCounter();
        incrementEliminatedCounter();
        handleEndlessMode(renderMode);
        
        renderBoard(renderMode);
        showMsg(renderMode, `Block ${sType} eliminated`);
        
        if(countBlocks() === 0 && currentMode !== 'endless'){
          const elapsedTime = currentMode === 'play' ? (Date.now() - playStartTime) :
                             currentMode === 'editorTest' ? (Date.now() - editorStartTime) : 0;
          const moves = currentMode === 'play' ? playMoves : editorMoves;
          const eliminated = currentMode === 'play' ? playEliminated : editorEliminated;
          showVictoryModal(renderMode, moves, eliminated, elapsedTime);
        } else if(checkDeadlock() && currentMode !== 'endless') {
          const elapsedTime = currentMode === 'play' ? (Date.now() - playStartTime) :
                             currentMode === 'editorTest' ? (Date.now() - editorStartTime) : 0;
          const moves = currentMode === 'play' ? playMoves : editorMoves;
          const eliminated = currentMode === 'play' ? playEliminated : editorEliminated;
          showGameOverModal(renderMode, moves, eliminated, elapsedTime);
        }
        
        isAnimating = false;
      });
      return;
    }

    const movingBlockSet = new Set([`${sx},${sy}`]);
    const actionSequence = [];
    const result = resolveTeleportChain(sx, sy, sType, nx, ny, dir, 0, movingBlockSet, sx, sy, null, actionSequence, isHard);
    
    if(!result.success){
      showMsg(renderMode, result.message);
      return;
    }

    isAnimating = true;
    
    if(currentMode === 'play' && !playStartTime) {
      playStartTime = Date.now();
    } else if(currentMode === 'editorTest' && !editorStartTime) {
      editorStartTime = Date.now();
    } else if(currentMode === 'endless' && !endlessStartTime) {
      endlessStartTime = Date.now();
    }
    
    executeAnimationSequence(actionSequence, renderMode).then(() => {
      if(result.eliminated){
        selected = null;
        incrementEliminatedCounter();
        showMsg(renderMode, `Block ${sType} teleported and eliminated`);
      } else if(result.swap){
        const {swapPortalX, swapPortalY, swapPortalType, finalX, finalY} = result;
        board[sy][sx] = 0;
        board[swapPortalY][swapPortalX] = 0;
        board[finalY][finalX] = sType;
        board[sy][sx] = swapPortalType;
        selected = {x:finalX, y:finalY};
        showMsg(renderMode, `Swap complete`);
      } else {
        const {finalX, finalY} = result;
        board[sy][sx] = 0;
        board[finalY][finalX] = sType;
        selected = {x:finalX, y:finalY};
        showMsg(renderMode, `Moved`);
      }
      
      incrementMoveCounter();
      handleEndlessMode(renderMode);
      
      renderBoard(renderMode);
      
      if(countBlocks() === 0 && currentMode !== 'endless'){
        const elapsedTime = currentMode === 'play' ? (Date.now() - playStartTime) :
                           currentMode === 'editorTest' ? (Date.now() - editorStartTime) : 0;
        const moves = currentMode === 'play' ? playMoves : editorMoves;
        const eliminated = currentMode === 'play' ? playEliminated : editorEliminated;
        showVictoryModal(renderMode, moves, eliminated, elapsedTime);
      } else if(checkDeadlock() && currentMode !== 'endless') {
        const elapsedTime = currentMode === 'play' ? (Date.now() - playStartTime) :
                           currentMode === 'editorTest' ? (Date.now() - editorStartTime) : 0;
        const moves = currentMode === 'play' ? playMoves : editorMoves;
        const eliminated = currentMode === 'play' ? playEliminated : editorEliminated;
        showGameOverModal(renderMode, moves, eliminated, elapsedTime);
      }
      
      isAnimating = false;
    });
  }
  
  function incrementMoveCounter() {
    if(currentMode === 'play') {
      playMoves++;
      updatePlayScore();
    } else if(currentMode === 'editorTest') {
      editorMoves++;
      updateEditorScore();
    }
  }
  
  function incrementEliminatedCounter() {
    if(currentMode === 'play') {
      playEliminated++;
      updatePlayScore();
    } else if(currentMode === 'editorTest') {
      editorEliminated++;
      updateEditorScore();
    } else if(currentMode === 'endless') {
      endlessEliminated++;
      updateEndlessScore();
    }
  }
  
  function handleEndlessMode(renderMode){
    if(currentMode === 'endless'){
      endlessMoves++;
      movesUntilNewBlocks--;
      updateEndlessScore();
      
      if(movesUntilNewBlocks <= 0){
        if(!addRandomPairEndless()){
          return;
        }
        movesUntilNewBlocks = endlessRefreshSteps;
      }
      
      if(checkDeadlock()) {
        const elapsedTime = endlessStartTime ? Date.now() - endlessStartTime : 0;
        showGameOverModal('endless', endlessMoves, endlessEliminated, elapsedTime);
      }
    }
  }

  function resolveTeleportChain(movingX, movingY, movingType, startX, startY, dir, depth, movingBlockSet, originX, originY, potentialSwapPortal, actionSequence, hardMode){
    if(depth > 50) return {success:false, message:'Recursion limit exceeded'};

    let encounteredType = board[startY][startX];
    let currentX = startX, currentY = startY;
    let stepGuard = 0;
    const visited = new Set();
    
    actionSequence.push({
      type: 'slideInto',
      fromX: movingX,
      fromY: movingY,
      toX: startX,
      toY: startY,
      blockType: movingType,
      portalType: encounteredType
    });

    while(stepGuard++ < 100){
      const posKey = `${currentX},${currentY}`;
      if(visited.has(posKey)) return {success:false, message:'Loop detected'};
      visited.add(posKey);

      const portal = findOtherOfType(encounteredType, currentX, currentY);
      if(!portal) return {success:false, message:`Cannot find pair`};

      if(portal.x === originX && portal.y === originY && potentialSwapPortal){
        actionSequence.push({
          type: 'swap',
          movingX: movingX,
          movingY: movingY,
          movingType: movingType,
          swapX: potentialSwapPortal.x,
          swapY: potentialSwapPortal.y,
          swapType: potentialSwapPortal.type
        });
        return {
          success: true, swap: true,
          swapPortalX: potentialSwapPortal.x,
          swapPortalY: potentialSwapPortal.y,
          swapPortalType: potentialSwapPortal.type,
          finalX: potentialSwapPortal.x,
          finalY: potentialSwapPortal.y
        };
      }

      let landX = portal.x + dir.x;
      let landY = portal.y + dir.y;

      if(!inside(landX, landY)){
        if(hardMode){
          return {success:false, message:'Hard mode: Cannot teleport at boundary'};
        }
        
        const oppX = portal.x - dir.x;
        const oppY = portal.y - dir.y;
        if(!inside(oppX, oppY)) return {success:false, message:'Boundary blocked'};

        const oppVal = board[oppY][oppX];
        if(oppVal === 0){
          actionSequence.push({
            type: 'portalMakeSpace',
            portalX: portal.x,
            portalY: portal.y,
            toX: oppX,
            toY: oppY,
            portalType: encounteredType
          });
          movePiece(portal.x, portal.y, oppX, oppY);
          landX = portal.x; landY = portal.y;
        } else if(oppVal === encounteredType){
          actionSequence.push({
            type: 'portalEliminate',
            x1: portal.x,
            y1: portal.y,
            x2: oppX,
            y2: oppY,
            blockType: encounteredType
          });
          board[portal.y][portal.x] = 0;
          board[oppY][oppX] = 0;
          landX = portal.x; landY = portal.y;
        } else {
          const portalType = board[portal.y][portal.x];
          const reverseDir = {x: -dir.x, y: -dir.y};
          const portalTargetX = portal.x + reverseDir.x;
          const portalTargetY = portal.y + reverseDir.y;
          
          if(!inside(portalTargetX, portalTargetY)) return {success:false, message:'Portal cannot make space'};
          const portalTargetVal = board[portalTargetY][portalTargetX];
          if(portalTargetVal === 0) return {success:false, message:'Reverse direction is empty'};
          
          const portalKey = `${portal.x},${portal.y}`;
          if(movingBlockSet.has(portalKey)) return {success:false, message:'Deadlock detected'};
          
          if(portalTargetVal === portalType){
            actionSequence.push({
              type: 'portalPushEliminate',
              portalX: portal.x,
              portalY: portal.y,
              targetX: portalTargetX,
              targetY: portalTargetY,
              portalType: portalType
            });
            board[portal.y][portal.x] = 0;
            board[portalTargetY][portalTargetX] = 0;
            landX = portal.x; landY = portal.y;
          } else {
            const newMovingBlockSet = new Set(movingBlockSet);
            newMovingBlockSet.add(portalKey);
            const swapInfo = {x: portal.x, y: portal.y, type: portalType};
            
            const portalMoveResult = resolveTeleportChain(
              portal.x, portal.y, portalType,
              portalTargetX, portalTargetY,
              reverseDir, depth + 1, newMovingBlockSet,
              originX, originY, swapInfo, actionSequence, hardMode
            );
            
            if(!portalMoveResult.success) return portalMoveResult;
            if(portalMoveResult.swap) return portalMoveResult;
            
            if(portalMoveResult.eliminated){
              landX = portal.x; landY = portal.y;
            } else {
              board[portal.y][portal.x] = 0;
              board[portalMoveResult.finalY][portalMoveResult.finalX] = portalType;
              landX = portal.x; landY = portal.y;
            }
          }
        }
      }

      if(inside(landX, landY)){
        const landingVal = board[landY][landX];
        if(landingVal === 0){
          if(currentX !== portal.x || currentY !== portal.y){
            actionSequence.push({
              type: 'teleport',
              fromX: currentX,
              fromY: currentY,
              toX: portal.x,
              toY: portal.y,
              blockType: movingType
            });
          }
          actionSequence.push({
            type: 'slideOut',
            fromX: portal.x,
            fromY: portal.y,
            toX: landX,
            toY: landY,
            blockType: movingType,
            portalType: encounteredType
          });
          return {success:true, finalX: landX, finalY: landY};
        }
        
        if(landingVal === movingType){
          if(landX === movingX && landY === movingY) return {success:false, message:'Back to start'};
          if(currentX !== portal.x || currentY !== portal.y){
            actionSequence.push({
              type: 'teleport',
              fromX: currentX,
              fromY: currentY,
              toX: portal.x,
              toY: portal.y,
              blockType: movingType
            });
          }
          actionSequence.push({
            type: 'slideOutAndEliminate',
            fromX: portal.x,
            fromY: portal.y,
            toX: landX,
            toY: landY,
            blockType: movingType,
            portalType: encounteredType
          });
          board[landY][landX] = 0;
          board[movingY][movingX] = 0;
          return {success:true, eliminated:true};
        }
        
        if(currentX !== portal.x || currentY !== portal.y){
          actionSequence.push({
            type: 'teleport',
            fromX: currentX,
            fromY: currentY,
            toX: portal.x,
            toY: portal.y,
            blockType: movingType
          });
        }
        
        actionSequence.push({
          type: 'slideInto',
          fromX: portal.x,
          fromY: portal.y,
          toX: landX,
          toY: landY,
          blockType: movingType,
          portalType: landingVal
        });
        
        encounteredType = landingVal;
        currentX = landX; currentY = landY;
      }
    }
    return {success:false, message:'Max chain length exceeded'};
  }

  function setupVirtualControls() {
    const controlSets = [
      document.getElementById('playControls'),
      document.getElementById('endlessControls'),
      document.getElementById('editorControls')
    ];
    
    controlSets.forEach(controlSet => {
      if (!controlSet) return;
      
      const buttons = controlSet.querySelectorAll('.control-btn');
      buttons.forEach(btn => {
        btn.addEventListener('touchstart', (e) => {
          e.preventDefault();
          handleDirectionPress(btn.dataset.key);
        });
        
        btn.addEventListener('mousedown', () => {
          handleDirectionPress(btn.dataset.key);
        });
      });
    });
  }
  
  function handleDirectionPress(key) {
    if (DIRS[key]) {
      slideSelected(key);
    }
  }

  window.addEventListener('keydown', (e)=>{
    if(DIRS[e.key]){
      e.preventDefault();
      slideSelected(e.key);
    }
  });

  resetRandom();
  setupVirtualControls();
</script>
</body>
</html>